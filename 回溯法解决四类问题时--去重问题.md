# 		回溯法解决四类问题时--去重问题

[TOC]

去重可以分为两种情况：

- 树枝去重
- 树层去重

#### 1.组合问题

问题：给定一个数组nums 和一个目标数 target ，找出 nums中所有可以使数字和为 target 的组合。

nums 中的每个数字在每个组合中只能使用一次,**nums中存在相同的元素**。

例如：nums = [2,5,2,1,2], target = 5;

答案：[1,2,2],[5]

当nums中存在重复元素时，**如何去重？**

明确该问题为树层去重，因为答案[1,2,2]可以出现重复的元素。

通过下面的图片明白选取最左边的1时，1下面递归的结果包括右边的1

![](https://camo.githubusercontent.com/19c848f21bf2791ae46871015f703b614fe19789da7cd68c9515a050266a8089/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303233303331303030303931382e706e67)

<font size = 6 >**如下这两个方法去重前，需要对nums进行排序**</font>

方法1：

`if(i > startIndex && nums[i] == nums[i - 1]) continue; `

```c++
void backtracking(...) {
    if(循环结束条件) {
        
    }
    for(int i = startIndex; i < endIndex; i++) {
        if(i > startIndex && nums[i] == nums[i - 1]) continue; 
    }
}
```

方法2：

`if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue;`

```c++
void backtracking(vector<bool>& used,...) {
        if (循环结束条件) {
        }
        for (int i = startIndex; i < endIndex; i++) {
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue;        
        }
    }

```

#### 2.子集问题

问题：给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

- 输入: [1,2,2]
- 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]

**去重方法与组合问题是一样的。**

![](https://camo.githubusercontent.com/9bf54f50895f39143eb86212493192fd2785477ce470dd02f68b3eac1d524554/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343139353431313937372e706e67)

#### 3.排列问题

问题：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

- 输入：nums = [1,1,2]
- 输出： [[1,1,2], [1,2,1], [2,1,1]]

方法1：

```c++
	void backtracking (vector<bool>& used,...) {
        // 此时说明找到了一组
        if (循环结束条件) {
        }
        for (int i = 0; i < endIndex; i++) {
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            if (used[i] == false) {
         		//回溯部分
            }
        }
    }


```

方法2：

```c++
void backtracking (vector<bool>& used,...) {
        // 此时说明找到了一组
        if (循环结束条件) {
        }
        for (int i = 0; i < endIndex; i++) {
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
                continue;
            }
            if (used[i] == false) {
         		//回溯部分
            }
        }
    }
```

为什么去重无法使用`if(i > startIndex && nums[i] == nums[i - 1])`?

因为排列问题中不存在startIndex, 同时为了避免在树枝上重复选择同一元素需要使用used数组进行标记

对于`if(used[i - 1] == true...)`与`if(used[i - 1] == false)`

true 代表对树枝去重，false代表对树层去重，两者达到的效果是一致的。

如下图：

**树层**

![](https://camo.githubusercontent.com/d376a49f4a94ac97d3cf49210f27b85b3efbb4342bd9c43f54abf45ab83bdc9c/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313430363139322e706e67)

**树枝**

![](https://camo.githubusercontent.com/152d38ad66c1f7ef4e32e9ce709eb36132b721d94fb4cc37264c49d1825255bc/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313433313537312e706e67)