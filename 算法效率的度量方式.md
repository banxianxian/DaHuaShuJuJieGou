## 算法效率的度量方式



[TOC]



### 事后统计

​	受太多方面的影响，一般不使用



### 事前分析

#### 程序运行的时间的影响因素

1. 算法采用的策略，方法
2. 编译产生代码的质量
3. 问题输入规模
4. 机械执行指令的速度

我们只分析1，3

### 大O记法

**函数的渐近增长**：给定两个函数f~（n）~，g~（n)~，如果存在一个正整数N，使得当n>N时，f~(n)~>g~(n)~

恒成立，则称**f**的渐近增长快于**g**。

```c++
//    计算0-n和
//	  算法1
int sum = 0;					//执行1次
for(int i=1; i<=n; i++) {		//执行n+1次
    sum += i;					//执行n次
}
// 		一共执行2n+2次

//  	算法2
int sum=0;						//执行1次
sum = (1+n)*n/2					//执行1次
// 		一共执行2次
    
// f(n)=2n+2,g(n)=2
// 当N=1时, f(n)>g(n),
 // 故f(n)的渐近增长快于g(n)
  
```

**时间复杂度**：T(n）为总的执行次数，记T(n) = O (f(n))

f(n) 为解决问题规模为n的函数

称O（ ）为 大O记法

**推导大O（）：**

对于程序我们只关心它实现的算法，故不考虑**循环索引的递增，循环终止条件，变量声明**等，对于**非循环内的分支**也不考虑

1. 用常数1取代运算时间的所有加法常数
2. 保留最高阶项
3. 如果最高阶项存在且不为1，删去前面的系数

```c
//	按上面算法1		f(n) = 2n+2
//	1. 2n+1
//  2. 2n
//	3.n
//故用大O记法，表示为T(n)=O(n); 称为线性阶

```

**大致分类**：

- 常数阶
- 线性阶
- 对数阶
- 平方阶

```c
// 	对数阶举例

int count = 1;
while(count < n ){
    count = count * 2;
    /* O(1)复杂度的操作 */
}
// 由2的x阶<n, 可得 x=log(n) （下标为2）
// 用O记法表示为O(logn)
```

**对于循环嵌套情况用循环次数*内部的复杂度**

```c
for(int i=0; i< n ; i++) {
    for(int j=0; j<n ; j++){
        /* 复杂度为O(1)*/
    }
}

//	T(n)= n* n* O(1)=n*O(n)=O(n*n)
```

**复杂度消耗时间排序**：

O(1) 	< 	O(logn) 	< 	O(n) 	<	 O(nlongn) 	< 	O(n*n)

**最坏时间复杂度与平均时间复杂度**：

一般未声明，则时间复杂度指最坏时间复杂度