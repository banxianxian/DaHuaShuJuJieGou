<div align=center><font size  = 8>散列表（哈希表）</font></div>

[TOC]

### 定义

在**静态表**与**动态表**查找，通过进行依次**比较**查找到目标值，而散列表查找可以通过你输入的关键字(*key*)直接返回查找结果。即通过函数**存储位置 = f(key)**。



### 优缺点

优点：

- 适合查找与给定值相等的数据，即<u>判断**有**还是**没有**</u>，且速度快(高于静态表与动态表)，O(1)

缺点：

- 不适合同一关键字（不是主关键字）对应多条数据

- 不适合查找满足范围的一些或一个数据
- 可能会发生哈希碰撞：f(key1) = f(key2)。

为了解决第三条缺点，需要构造一个合适的散列（哈希）函数，下面有一些常用的方法：



### 构造合适的散列函数

##### 原则：

- 函数的计算简单
- 数据要分布均匀，避免哈希碰撞

##### 方法：

**说明**：下面的关键字均为数字，对于非数字的可以使用ascil码转为数字，用于存储的哈希表可以看为数组，哈希地址视为数组下标

下面方法最重要的是**除留余数法**



###### 除留余数法：f(key) = key mod p (p <= 哈希表长)

该方法的重点在于选取合适的p，小于等于表长保证不会越界

> 通常p为<= 哈希表长（最好接近表长）的最小质数或不包含小于20质因子的合数

合数的质因子应该大于20.

1即不是质数也不是合数

下面解释质因子的概念：20 = 1 * 20 = 2 * 10 = 4 * 5 

其中5为质数，即为质因子



###### 直接定址法：f(key) = a * key + b

适合情况：知道**关键字的分布**，且数据量小且连续

> 如果不连续，且数据量大，会产生巨大的空间浪费比如将1982改为3000，空间需要开到1020，中间地址内容均为空

优点：计算简单，数据均匀**不会**发生哈希碰撞

列如：

| 地址 | 出生年份 | 人数   |
| ---- | -------- | ------ |
| 00   | 1980     | 1500万 |
| 01   | 1981     | 1600万 |
| 02   | 1982     | 1300万 |

> f(key) = key - 1980



###### 平方取中法: f(key) = 抽取中间(key * key)

适合范围：不知道关键字分布情况，且**关键字位数不多**

例如：1234

1234 * 1234 = 1522756

如果哈希表长为三位（即数组最大下标为999），可以取中间227三位作为地址



###### 折叠法

将关键字从左到右分为若干位数相等的部分，再将各部分依次求和

适合范围：不知道关键字分布情况，且**关键字位数多**

列如：9876543210

987 + 654 + 321 + 0 = 1962

如果哈希表长为三位（即数组最大下标为999），分10 / 3 = 3（向下取整）组

可以取后面962三位作为地址



###### 数字分析法

通过**抽取**关键字的**部分**作为地址

适合情况：关键字较长，事先知道关键字的分布情况，且关键字分布均匀



###### 随机数法

不介绍



### 解决哈希冲突的方法

哈希函数的构造是为了避免哈希冲突的产生，而当冲突产生时，亦有处理的方法。

###### 开放定址法

**做法：**当发生哈希冲突，冲突元素发生时寻找空地址填入，称“**线性探测法**”。

**堆积：** 我们把不是同义词却通过哈希函数转换到同一个地址发生冲突的现象称作堆积。



###### 再散列函数法

**做法：** 准备多个哈希函数，当发生哈希冲突，换一个哈希函数重新计算一个地址。



###### 链地址法

**做法：** 当发生哈希冲突时，在冲突的地址建立一个链表结构，将冲突的同义词放到链表上面。



###### 链地址法



### 实现代码

```c++
// 下面的演示代码用int作为关键字key，其对应的数据项为string
#include <iostream>
#include <vector>
using namespace std;
// 用结构体作为hashmap的容器
struct Hashmap {
	vector<string> box;		// 装填数据项的容器
	int count;			// 哈希表目前的元素个数
	int m;				// 哈希表的表长
	Hashmap(int m): m(m) {
		box.resize(m, "-1");
		count = 0;
	}
	int hashFun(int key);
	void insertHash(int key, string content);
	string operator[](int key) {
		int index = key;
		index = hashFun(index);
		// 如果使用开放定址法的话，需要插入content比较，但是[]只传入一个参数，有问题
		/*
		while (box[index] != content) {
			index = (index + 1) % m;
		}
		*/
		return box[index];
	}
};

// 除留取余法构造的哈希函数
int Hashmap::hashFun(int key) {
	int p = 0;
	for (int i = 3; i < m; i += 2) {
		int status = 0;
		for (int j = 3; j <= sqrt(m); j += 2) {
			if (i % j == 0) {
				status = 1;
			}
		}
		if (!status) {
			p = i;
		}
	}

	return key % p;
}


void Hashmap::insertHash(int key, string content) {
	int address = hashFun(key);
	while (box[address] != "-1") {
		// 开放定址法
		address = (address + 1) % m;
	}
	// 把关键字当作要插入的数据项的全部内容
	box[address] = content;
	// 当前容器有的元素+1
	count++;
}


int main() {
	
	pair<int, string> nums[3] = { {4, "hello"}, {15, "good"}, {45, "girl"}};
	struct Hashmap hashmap(20);
	for (int i = 0; i < 3; i++) {
		hashmap.insertHash(nums[i].first, nums[i].second);
	}

	cout << hashmap[4] << " " << hashmap[15] << " " << hashmap[45] << endl;
    return 0;
}
```

