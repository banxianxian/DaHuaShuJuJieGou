<div align = center><font size =  10>位运算</font></div>

[TOC]

#### 定义

对一个bit位的操作。

#### 基本的位运算

位运算分为**逻辑位运算**和**位移位运算**

| 名字 | 符号 | 含义                                                         |
| ---- | ---- | ------------------------------------------------------------ |
| 位与 | &    | 同1为1（逻辑与，$\bigcap$）                                  |
| 位或 | \|   | 同0为0 （逻辑或，$\bigcup$）                                 |
| 异或 | ^    | 相同为0，不同为1                                             |
| 取反 | ~    | 单目运算符，0变1，1变0                                       |
| 左移 | <<   | x << n，向左移动n位，高位舍弃，低位补0                       |
| 右移 | >>   | x >> n，向右移动n位，低位舍弃，最高位如果为1，则补1，反之补0 |

#### 代码演示

##### 变量定义

```c++
int a = 10;	// 二进制 00000000 00000000 00000000 00001010
int b = 12;	// 二进制 00000000 00000000 00000000 00001100
int c = 0;
```



##### 位与（&）

```c++
// 逻辑 位与运算符 & 同1取1
// a: 00000000 00000000 00000000 00001010
// b: 00000000 00000000 00000000 00001100
// 00001000 -> 8
c = a & b;
cout << "a & b = " << c << endl;

// 输出 a & b = 8
```

##### 位或（|）

```c++
// 逻辑 位或运算 | 同0为0
// a: 00000000 00000000 00000000 00001010
// b: 00000000 00000000 00000000 00001100
// 00001110 -> 14
c = a | b;
cout << "a | b = " << c << endl;

// 输出 a | b = 14
```

##### 异或（^）

```c++
// 逻辑 异或运算 ^ 同0异1
// a: 00000000 00000000 00000000 00001010
// b: 00000000 00000000 00000000 00001100
// 00000110 -> 6
c = a ^ b;
cout << "a ^ b = " << c << endl;

// 输出 a ^ b = 6
```

##### 取反 （~）

```c++
// 逻辑 取反运算 ~ 0变1 1变0
// ~a 11111111 11111111 11111111 11110101 -> -11
// a: 00000000 00000000 00000000 00001010
// ~b 11111111 11111111 11111111 11110011 -> -13
// b: 00000000 00000000 00000000 00001100
c = ~a;
cout << "~a = " << c << endl;
c = ~b;
cout << "~b = " << c << endl;

// 负数用补码表示，后面介绍
// 输出 ~a = -11
//		~b = -13
```

##### 左移（<<）

```c++
// 位移运算符 左移 x << n 将二进制位向左移动n位，高位舍弃，低位补0
// a << 2 00101000 40 
// b << 2 00110000 48
c = a << 2;
cout << "a << 2 = " << c << endl;

c = b << 2;
cout << "b << 2 = " << c << endl;

// 输出 a << 2 = 40
// 输出 b << 2 = 48
```

##### 右移（>>）

```c++
// 位移运算符 右移 x >> n 将二进制位向右移动n位，高位补0或1，低位丢弃
// 如果最高位为1，则补1。如果最高位为0，则补0
// a >> 2 00000010 2 
// b << 2 00000011 3
c = a >> 2;
cout << "a >> 2 = " << c << endl;
c = b >> 2;
cout << "b >> 2 = " << c << endl;

// 输出 a >> 2 = 2
// 输出 b >> 2 = 3
```

#### 原码，反码，补码

##### 三者转换的方法

计算机进行加减运算时，用补码进行计算，在将负数补码形式转换为10进制，可以优先转换为原码

**注意**：计算机**只有加法运算器**，**没有减法运算器**

**正整数** ： 原码 = 反码 = 补码

**负整数**： 反码 = 原码的标志位不变，其它位取反

​		 	    补码 = 反码 + 1

例如：

| 以4字节(int) |                                     |
| ------------ | ----------------------------------- |
| -21          |                                     |
| 原码         | 10000000 00000000 00000000 00010101 |
| 反码         | 11111111 11111111 11111111 11101010 |
| 补码         | 11111111 11111111 11111111 11101011 |

##### 为什么存在反码与补码

###### +-0 +-1 +-2 的原反补码

| 以一个字节表示 | 原码      | 反码      | 补码      |
| -------------- | --------- | --------- | --------- |
| +0             | 0000 0000 | 0000 0000 | 0000 0000 |
| -0             | 1000 0000 | 1000 0000 | 1000 0000 |
| 1              | 0000 0001 | 0000 0001 | 0000 0001 |
| -1             | 1000 0001 | 1111 1110 | 1111 1111 |
| 2              | 0000 0010 | 0000 0010 | 0000 0010 |
| -2             | 1000 0010 | 1111 1101 | 1111 1110 |

###### 为什么引入补码

**tip1**：计算机**只有加法运算器**，**没有减法运算器**，引入反码以及补码是为了解决减法运算

**原码**：是最简单的机器数表示法，用最高位表示**符号位（0代表+，1代表-）**，其他位存放该数的二进制的绝对值

**tip2：**减法运算可以看作加法运算，例如1-1 可以看作 1+ （-1）

观察**原码**相加：1 + (-1) = 1000 0010，这个相加并不等于0，故原码无法解决**相反数相加为0**情况

观察**反码**相加：1+（-1）= 1111 1111 这个原码为1000 0000 为0，故反码解决了互为相反数相加为0的情况。

再观察-1 + (-1) = 0000 0000 为0 不等于-2，故反码无法解决**负数的加法**，同时无法解决**大正数 + 小负数**的情况。

而**补码**可以解决上面两个问题。

###### 补码原理

思想：对于一个时钟，8点 + 2点 = 10点，8点 - 10点 = 10点 ，**减法**可以用**两个正数加法**替代

存在一个模的概念：在时钟 模 = 12 = 最大值 + 1 (时钟中最大值为11)

**3位二进制**：

| 0 000 |
| ----- |
| 0 001 |
| 0 010 |
| 0 011 |
| 0 100 |
| 0 101 |
| 0 110 |
| 0 111 |

**下面运算没有表现符号位：**

**模**为 0111 + 1 = **8**

例子为计算5 - 2

5 - 2 = 5 + （模- 2） = 5 +（8 - 2）= 5 + 6 = 101 + **110** = 011 = 3

**101** 为**5 的补码**

**110** 为**-2的补码**  ，也就是说**8 - 2** 就是**-2的补码**。

<u>下面证明8 - 2 为 -2 的补码：</u>

-2 的原码 = 010，        反码 = 101，         补码 = 110

反码 = 111 - 原码

补码 110 = 反码 + 1 = 101 + 1 = 111 - 原码 + 1 = 111 + 1 - 010 = 模 - 010 = **模 - 原码**