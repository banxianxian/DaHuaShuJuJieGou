<div align=center><font size=7>数学</font></div>

[TOC]

#### 1. 位运算和进制转换

位运算**异或**具有交换律，并且0^a = a，a ^ a = 0



##### 题解

###### Luogu1469

**思路：** 位运算异或具有交换律，并且0^a = a，a ^ a = 0

```c++
#include <iostream>
using namespace std;
int n;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    int target = 0;
    int temp = 0;
    for(int i = 0; i < n; i++) {
        cin >> temp;
        target ^= temp;
    }

    cout << target << endl;
    return 0;
}
```

###### Luogu1100

```c++
#include <iostream>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cout.tie(0),cin.tie(0);

    unsigned int x = 0;
    cin >> x;
    unsigned int y = ((x & 0xffff0000) >> 16) | (x << 16);
    cout << y << endl;

    return 0;
}
```

###### Luogu1017

```c++
#include <iostream>
using namespace std;
char int_to_char(int x) {
    return x <= 9? x + '0': x - 10 + 'A';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    int n = 0, base = 0;
    cin >> n >> base;
    cout << n << "=";
    int output[200] = {0};

    // 将n转换为base进制的数字
    int cnt = 0;
    int temp1 = 0, temp2 = 0;
    while(n) {
        temp1 = n % base;
        temp2 = n / base;
        if(temp1 < 0) {
            temp2 = temp2 + 1;
            temp1 = -base + temp1;
        }
        n = temp2;
        output[cnt++] = temp1;
    }

    
    cnt--;
    for(;cnt >= 0; cnt--) {
        cout << int_to_char(output[cnt]);
    }
    cout << "(base" << base << ")" << endl;
    return 0;
}
```



#### 2.  计数原理与排列组合

- **加法原理**
- **乘法原理**
- **排列和组合**

一些有用的结论：

- (a + b + c) % k == ((a + b) % k) % k
- (abc) % k == ((ab) % k) % k
- $A_n^m = \frac{n!}{(n-m)!}$
- $C_n^m = C_{n-1}^{m-1} + C_{n-1}^m$  (帕斯卡公式)
- $C_n^m=\frac{n!}{m!\times(n-m)!}$

**组合数的求解方式：**

如果直接使用$C_n^m=\frac{n!}{m!\times(n-m)!}$ ，存在阶乘的运算很容易溢出，相反是使用帕斯卡公式递推求解得到一个组合数表。

**模板：**

复杂度：O($n^2$)

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN = 25;
long long C[MAXN][MAXN];	// 第一维代表下标1，第二维代表上标
int n, m;
int main() {
	cin >> n >> m;
	for(int i = 0; i <= 21; i++) {
		C[i][0] = 1;
		C[i][i] = 1;
		for(int j = 1; j < i; j++) {
			C[i][j] = C[i-1][j-1] + C[i-1][j];
		}

	}

	cout << C[n][m] << endl;
	return 0;
}
```



##### 题解

###### Luogu3913

**注意：** ans应该要开到long long

```c++
#include <iostream>
#include <unordered_set>
using namespace std;
int N, K;
unordered_set<int> row;
unordered_set<int> col;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N >> K;
    long long ans = 0;
    for(int i = 0; i < K; i++) {
        int tempx, tempy;
        cin >> tempx >> tempy;
        row.insert(tempx);
        col.insert(tempy);
    }

    ans = (long long)row.size() * N + (long long)(N - row.size()) * col.size();
    cout << ans << endl;

    return 0;
}
```

###### Luogu1246

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
#include <queue>
using namespace std;
unordered_map<string, int> box2;
int cnt = 1;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    queue<string> box;
    for(char ch = 'a'; ch <= 'z'; ch++) {
        string temp = " ";
        temp[0] = ch;
        box.push(temp);
    }

    while(!box.empty()) {
        string x = box.front();
        box.pop();
        char last = x[x.size() - 1];
        if(x.size() > 6) continue;
        box2[x] = cnt++;
        for(char ch = last + 1; ch <= 'z'; ch++) {
            string temp = x;
            temp.push_back(ch);
            box.push(temp);
        }
        
    }
   string one;
   cin >> one;
   cout << box2[one] << endl;
    return 0;
}
```

###### Luogu2789

刚开始一直想直接找到线方案数的递推关系，但是考虑有1-N条线平行情况，再考虑N-i条线情况存在重复，无法有效解决。

**正确的解题思路:** 求解所用可能的点数目，并用数组记录，最后统计答案

```c++
#include <iostream>
using namespace std;
const int MAXN = 1005;
int N;
int nums[MAXN];
void dfs(int edge, int node) {
    if(edge == 0) {
        nums[node] = 1;
        return;
    }

    for(int i = 1; i <= edge; i++) {
        int t = (edge - i) * i;
        dfs(edge - i, node + t);
    }

}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N;

    // 考虑N条线，依次考虑1-N条线平行的情况
    for(int i = 1; i <= N; i++) {
        int node = (N - i) * i;
        dfs(N - i, node);
    }

    // 统计答案
    int ans = 0;
    for(int i = 0; i < MAXN; i++) {
        if(nums[i] == 1) ans++;
    }
    cout << ans << endl;
    return 0;
}
```

###### Luogu2638

**思路：** 本题使用记忆化搜索，还有其它解法

**注意：** 下面的题解有一个测试样例无法过去，需要使用**高精度**

```c++
#include <iostream>
#include <cstring>
using namespace std;
int n, a, b;
unsigned long long  vis[50][50][50];
bool isvis[50][50][50];
unsigned long long  dfs(int a, int b, int t) {
    if(isvis[t][a][b]) return vis[t][a][b];
    if(t == 0) return 1;
    unsigned long long sum = 0;
    for(int i = 0; i <= a; i++) {
        for(int j = 0; j <= b; j++) {
            sum += dfs(a - i, b - j, t - 1);
        }
    }
    if(!isvis[t][a][b]) vis[t][a][b] = sum, isvis[t][a][b] = true;
    return sum;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    memset(vis, 0, sizeof(vis));
    cin >> n >> a >> b;

    cout << dfs(a, b, n) << endl;
    return 0;
}
```



#### 3. 整除理论

##### 1. 整除的基本知识

**%符号介绍：** A % B = C ，如果A为正整数，那么取模结果C为正整数，反之如果A为负整数，那么C为负整数。

使用思路：首先将A和B都变为正数，然后去余，再根据A的符号，确认C的符号

**示例：**

```c++
#include <iostream>

using namespace std;

int main()
{
	cout << 5 % 2 << endl;
	cout << 5 % -2 << endl;
	cout << -5 % 2 << endl;
	cout << -5 % -2 << endl;
	return 0;
}
// 输出
1
1
-1
-1
```

##### 2. 素数（质数）

**定义：**大于1的自然数，并且只能被1和本身整除

1既不是质数也不是合数

**定理：**

- 如果a为合数，则一定存在质数p|a，且p<=$\sqrt{a}$ 

**质数筛法**

###### 1. 素数判断方法

判断x是否为素数，如果是，返回true，否则返回false

**原理**：素数定义

```c++
bool isprime1(int x) {
    if(x == 2) return true;
    if(x % 2 == 0 || x == 1) return false;
    for(int i = 3; i <= x / i; i += 2) {
        if(x % i == 0) {
            return false;
        }
    }
    return true;
}
```



###### 2. 埃氏筛

**原理**：自然数可以分为自然数和合数，有下面定理：

> 一个合数可以分解为质数乘积（除了1和本身外的质数）

因而可以求解范围类的合数，从而达到求解质数的目标

```c++
int maxn = 1e6;			// 求解[1-maxn]范围的素数的个数
int vis[maxn + 10];		// 如果vis[i] = 0代表素数，1代表合数
vis[1] = 0;
void isprime2() {
    // 只需要考虑sqrt(maxn)范围的合数即可
    for(int i = 2; i <= maxn / i; i++) {
        // 如果为素数的话，进行倍增
        if(!vis[i]) {
            // j依次为i，2i，3i…………
            // i * i可能会发生越界，可以加入判断j >= 0
            for(int j = i * i; j <= manx && j >= 0; j += i) {
                vis[j] = 1;S
            }
        }
    }
    
}
```



##### 3. 最大公约数和最小公倍数



##### 题解
