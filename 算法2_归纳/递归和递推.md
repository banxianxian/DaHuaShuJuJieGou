<div align=center><font size=7>递归和递推</font></div>

[TOC]

##### 递推

**定义：**根据递推式和初始化条件，从初始条件开始向上推导直到结果。

##### 递归

**定义：**先递后规，首先将原问题分解为若干相同的子问题，直到最小子问题被解决，将结果向上递推得到答案。

##### 递归分类

1. 子集型回溯

​	子集型回溯有两种思考方式

​		a. 每个元素**选**或者**不选**

​		b. 每次必须**选择**一个元素，为了避免选择重复，需要规定一个顺序

2. 组合型回溯
3. 排列型回溯





##### 递归需要注意的问题

1. 递归问题，不要试图逐步演示去弄明白过程，只需要确定**递归式**和**递归结束条件**
2. 递归问题，应该尽量使用**记忆化搜索**，如果使用记忆化搜索，那么记录答案最好使**递归函数有返回值**，而不是用全局变量记录
3. 递归是先递后规，理论上慢于递推，递归和递推在很多情况下可以转换



##### 题解

###### Luogu2437

本题其实就是一个斐波拉其数，但会很大。

[100] = 21位

[300] = 63位

[700] = 146位

**注意在Bigint中要用memset函数对nums进行初始化**

```c++
#include <iostream>
#include <cstring>
using namespace std;
int n, m;
struct Bigint {
    int nums[1000];
    int len;
    Bigint(int x);
    Bigint();
    void print();
    Bigint operator+(Bigint one);
};
Bigint::Bigint(int x) {
    memset(nums, 0, sizeof(nums));
    len = 1;
    nums[1] = 1;
}
Bigint::Bigint() {
    memset(nums, 0, sizeof(nums));
    len = 0;
}
void Bigint::print() {
    for(int i = len; i >= 1; i--) {
        cout << nums[i];
    }
}
Bigint Bigint::operator+(Bigint one) {
    Bigint target;
    target.len = max(len, one.len) + 1;
    // 相加
    for(int i = 1; i <= target.len; i++) {
        target.nums[i] = nums[i] + one.nums[i];
    }

    // 进位
    for(int i = 1; i <= target.len; i++) {
        target.nums[i + 1] += target.nums[i] / 10;
        target.nums[i] %= 10;
    }

    // 平展，出理0
    for(;target.nums[target.len] == 0;) {
        target.len--;
    }
    return target;

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> m >> n;
    Bigint dp[3] = {1, 1, 1};
    for(int i = 0; i < n - m - 1; i++) {
        dp[2] = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = dp[2];
      
    }

    if(n == m + 1) {
        cout << "1" << endl;
    }
    else {
        dp[2].print();
    }
    
    return 0;
}
```

###### Luogu1164

该题为子集型回溯（递归），并且采用第二种思路**每次一定选择一个数**，并且利用index参数规定了一个顺序。同时使用记忆化搜索进行剪枝。

```c++
// 递归 记忆化搜索
#include <iostream>
#include <cstring>
using namespace std;
int M, N;
int menu[105];
int memory[10005][105];
int dfs(int M, int index) {
    if(M == 0) {
        return 1;
    }
    if(index == N || M < 0) {
        return 0;
    }
    if(memory[M][index] != -1) {
        return memory[M][index];
    }
    int ans = 0;
    for(int i = index; i < N; i++) {
        ans += dfs(M - menu[i], i + 1);
    }
    memory[M][index] = ans;
    return ans;
}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> N >> M;
    memset(memory, -1, sizeof(memory));
    for(int i = 0; i < N; i++) {
        cin >> menu[i];
    }
    if(N == 0 || M == 0) {
        cout << "0" << endl;
    }
    else cout << dfs(M, 0);
    return 0;
}
```

###### Luogu1036

采用的也是第二种思路，**每次一定选一个**

```c++
// 组合型问题的递归
#include <iostream>
using namespace std;
int n, k;
int nums[25];
bool isPrime(int x) {
    if(x == 2) return true;
    if(x % 2 == 0 || x == 1) return false;
    for(int i = 3; i * i <= x; i += 2) {
        if(x % i == 0) return false; 
    }
    return true;
}
int dfs(int sum, int index, int cnt) {
    if(cnt == k) {
        if(isPrime(sum)) {
            //cout << "sum = " << sum << endl;
            return 1;
        }
        else return 0;
    }
    if(index >= n) {
        return 0;
    }

    int ans = 0;
    for(int i = index; i < n; i++) {
        ans += dfs(sum + nums[i], i + 1, cnt + 1);
    }

    return ans;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << dfs(0, 0, 0);

    return 0;
}
```

###### Luogu1990

**注意：**题目要求只要输出后4位即可，只需要每次对**结果取余**即可。

**如果使用高精度代码会超时**。

**思路：**考虑第N时，因该想到N为新加的，依次作为分类标准（第N块然后被利用）。

```c++
#include <iostream>
#include <cstring>
using namespace std;
int N;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> N;
    long long dp[4] = {1, 1, 2, 5};
    
    for(int i = 3; i <= N; i++) {
        dp[3] = (dp[2] + dp[1] + dp[0] + dp[0]) % 10000;
        dp[0] = (dp[1] + dp[0]) % 10000;
        dp[1] = dp[2] % 10000;
        dp[2] = dp[3] % 10000;
    }


    if(N == 1) {
        cout << "1" << endl;
    }
    else if(N == 2) {
        cout << "2" << endl;
    }
    else {
        int cnt = 0;
        long long temp = dp[3];
        while(temp != 0) {
            temp /= 10;
            cnt++;
        }
        if(cnt >= 4) {
            cout << (dp[3] / 1000 % 10) << (dp[3] / 100 % 10) << (dp[2] / 10 % 10) << (dp[3] % 10);
        }
        else cout << dp[3];
    }
    return 0;
}
```

###### Luogu3612

本题用递推应该也可以很好解决

```c++
#include <iostream>
#include <cstring>
using namespace std;
typedef long long LL;
LL N1;
string a;
LL dfs(LL N, LL t) {
    if(N <= (LL)a.size()) {
        return N;
    }
    LL ans = 0;
    if(N == ((t >> 1) + 1)) {
        ans = dfs(N - 1, t >> 1);
    }
    else if(N <= (t >> 1)) {
        ans = dfs(N, t >> 1);
    }
    else {
        ans = dfs(N - (t >> 1) - 1, t >> 1);
    }
    
    return ans;
}
int main() {
    cin >> a >> N1;
    LL t = a.size();
    while(t < N1) {
        t = t << 1;
    }
    long long temp = dfs(N1, t);
    cout << a[temp - 1];
    return 0;
}
```

###### Luogu1259

本题实现更像**模拟题**，每个串变化分为两个阶段，阶段是在重复一个子问题（递归），后一阶段打表即可。

```c++
#include <iostream>
#include <cstring>
using namespace std;
int n;
char ch[205];
void print() {
    for(int i = 0; i < 2 * n + 2; i++) {
        cout << ch[i];
    }
    cout << endl;
}
int main() {
    memset(ch, 0, sizeof(ch));
    cin >> n;
    // 初始化
    int i = 0, j = 0;
    for(i = 0, j = n; i < n && j < 2 * n; i++, j++) {
        ch[i] = 'o';
        ch[j] = '*';
    }
    ch[j] = '-';
    ch[j + 1] = '-';

    int t1 = 0, t2 = 0, em1 = 0, em2 = 0;
    t1 = n - 1, t2 = n;
    em1 = j, em2 = j + 1;


    while(!(ch[3] == '-' && ch[4] == '-')) {
        print();
        swap(ch[t1], ch[em1]);
        swap(ch[t2], ch[em2]);
        swap(t1, em1);
        swap(t2, em2);
        if(t1 > em1) {
            t1 -= 2;
            t2 -= 2;
        }
        else {
            t1--;
            t2--;
        }
    }
    print();
    swap(ch[3], ch[7]);
    swap(ch[4], ch[8]);
    print();
    swap(ch[1], ch[7]);
    swap(ch[2], ch[8]);
    print();
    swap(ch[1], ch[6]);
    swap(ch[2], ch[7]);
    print();
    swap(ch[0], ch[6]);
    swap(ch[1], ch[7]);
    print();

    return 0;
}
```

###### Luogu1010

一道难度不大，但是特别典型的递归题。

**注意：**

1. 处理1时要特殊处理
2. 对于加号最后一个加号需要减去earse(location, length)

```c++
#include <iostream>
using namespace std;
int n;

string dfs(int n) {
    if(n == 0) {
        return string("0");
    }
    else if(n == 2) {
        return string("2");
    }
    // 将n分解
    string target;
    
    
    for(int j = 0; j <= 31; j++) {
        if(n << j < 0) {
            if(31 - j != 1) {
                target += (string)"2(";
                target += dfs(31 - j);
                target += (string)")";
                target += (string)"+";
            }
            else {
                target += (string)"2+";
            }
            
        }
    }
    if(target[target.size() - 1] == '+') {
        target.erase(target.size() - 1, 1);
    }

    return target;

}
int main() {
    cin >> n;
    cout << dfs(n);
    return 0;
}
```

###### Luogu1228

本题比较好。

**错误思路：**想着铺上一块砖会变成什么样子（与上个状态区别），从而递归

发现特别复杂，并且无法找到相似点

**正确思路：** 将一块大的模块分为4个小模块，判断公主在那个模块，对于其它三个模块选取三个位置（正中间的2*2区域内）作为一块要铺的砖，并且让这几个位置作为虚拟的公主位置继续递归4个小模块。

**注意：** 计算4个区间的坐标时，大模块区间范围为**x1 - x2**（行）, **y1  -  y2**（列）。4个小区间范围分别为

**左上**：x1 - (x1 + x2 - 1) / 2 ~~(注意不是x2 / 2),~~	y1 - (y1 + y2 - 1) / 2

 **左下：** （x1 + x2 + 1 ) / 2 - x2 ~~(注意不是 x2 / 2 + 1)~~,	y1 - (y1 + y2 - 1) / 2

其它同理。

```c++
#include <iostream>
#include <cstring>
using namespace std;
int x, y;
int k;
void dfs(int x1, int x2, int y1, int y2, int x, int y) {
    if (x2 - x1 == 1) {
        if (x == x1 && y == y1) {
            cout << x2 << " " << y2 << " " << "1" << endl;
        }
        else if (x == x1 && y == y2) {
            cout << x2 << " " << y1 << " " << "2" << endl;
        }
        else if (x == x2 && y == y1) {
            cout << x1 << " " << y2 << " " << "3" << endl;
        }
        else if (x == x2 && y == y2) {
            cout << x1 << " " << y1 << " " << "4" << endl;
        }
        return;
    }

    int status1 = 0;
    if (x >= x1 && x <= (x2 + x1 - 1) / 2 && y >= y1 && y <= (y2 + y1 - 1) / 2) {
        status1 = 4;
        dfs(x1, (x2 + x1 - 1) / 2, y1, (y2 + y1 - 1) / 2, x, y);
    }
    else {
        dfs(x1, (x2 + x1 - 1) / 2, y1, (y2 + y1 - 1) / 2, (x2 + x1 - 1) / 2, (y2 + y1 - 1) / 2);
    }

    if (x >= x1 && x <= (x2 + x1 - 1) / 2 && y >= (y1 + y2 + 1) / 2 && y <= y2) {
        status1 = 3;
        dfs(x1, (x2 + x1 - 1) / 2, (y2 + y1 + 1) / 2, y2, x, y);
    }
    else {
        dfs(x1, (x2 + x1 - 1) / 2, (y2 + y1 + 1) / 2, y2, (x2 + x1 - 1) / 2, (y2 + y1 + 1) / 2);
    }

    if (x >= (x2 + x1 + 1) / 2 && x <= x2 && y >= y1 && y <= (y2 + y1 - 1) / 2) {
        status1 = 2;
        dfs((x2 + x1 + 1) / 2, x2, y1, (y2 + y1 - 1) / 2, x, y);
    }
    else {
        dfs((x2 + x1 + 1) / 2, x2, y1, (y2 + y1 - 1) / 2, (x2 + x1 + 1) / 2, (y2 + y1 - 1) / 2);
    }

    if (x >= (x2 + x1 + 1)/ 2 && x <= x2 && y >= (y2 + y1 + 1) / 2 && y <= y2) {
        status1 = 1;
        dfs((x2 + x1 + 1)/ 2, x2, (y2 + y1 + 1) / 2, y2, x, y);
    }
    else {
        dfs((x2 + x1 + 1) / 2, x2, (y2 + y1 + 1) / 2, y2, (x2 + x1 + 1) / 2, (y2 + y1 + 1) / 2);
    }


    if (status1 == 4) {
        cout << (x2  + x1 + 1)/ 2 << " " << (y2 + y1 + 1) / 2  << " " << "1" << endl;
    }
    else if (status1 == 3) {
        cout << (x2 + x1 + 1)/ 2 << " " << (y1 + y2 - 1) / 2 << " " << "2" << endl;
    }
    else if (status1 == 2) {
        cout << (x2 + x1 - 1) / 2 << " " << (y2 + y1 + 1) / 2  << " " << "3" << endl;
    }
    else if (status1 == 1) {
        cout << (x2 + x1 - 1) / 2 << " " << (y2 + y1 -1) / 2 << " " << "4" << endl;
    }
}
int main() {
    cin >> k >> x >> y;

    int x1 = 1;
    int x2 = 1 << k;
    int y1 = 1;
    int y2 = 1 << k;
    if (k != 0) dfs(x1, x2, y1, y2, x, y);
    return 0;
}
```

