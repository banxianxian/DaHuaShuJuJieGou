<div align=center><font size=7>排序</font></div>

[TOC]

##### 指导

对于排序，大多数时候都是使用stl的sort()函数，所以对于简单排序：冒泡，选择，插入理解思路即可，对于新学习的**计数排序，快速排序**需要重点掌握思路和实现。以及部分**stl库函数**。

##### stl库函数

- sort()：第三个参数，如果返回true那么，第一个参数放在前面，如果返回false，第一个参数放在后面。
- unique(nums.begin(), nums.end())，该函数需要传入排序好的数组，对数组进行**去重**，并且返回去重后的最后一个元素地址,去重后元素个数=unique(nums.begin(), nums.end()) - nums.begin()
- nth_element(nums, nums + k, nums + n, cmp)，查找第k小的数字是什么，调用后直接访问**a[k]**即可，cmp可以自定义从大到小。

##### 重要排序（计数，快速）

**计数排序：** 时间复杂度为O(n)，n为数的范围max-min，适合排序的一列数中max-min较小，同时重复数字越多越好。

**快速排序模板：**

**思路：**使用分治的思想。

```c++
void qsort(int nums[], int left, int right) {
    int r = right, l = left, flag = nums[(right + left) / 2];
    do {
        while(nums[l] < flag) {
            l++;
        }
        while(nums[r] > flag) {
            r--;
        }
        if(l <= r) {
            swap(nums[l], nums[r]);
            l++, r--;
        }
	} while(l <= r);
    if(right > l) qsort(nums, l, right);
    if(left < r) qsort(nums, left, r);
}
```



##### 基本排序的实现模板

###### 1. 冒泡排序

```c++
for(int i = 0; i < n - 1; i++) {
    for(int j = i; j < n - i - 1; j++) {
        if(nums[j] > nums[j + 1]) {
            swap(nums[j], nums[j + 1]);
        }
    }
}
```

###### 2. 选择排序

```c++
for(int i = 0; i < n - 1; i++) {
    for(int j = i + 1; j < n; j++) {
        if(nums[j] < nums[i]) {
            swap(nums[j], num[i]);
        }
    }
}
```

###### 3. 插入排序

```c++
for(int i = 1; i < n - 1; i++) {
    int temp = nums[i];
    for(int j = i - 1; j >= 0; j--) {
        if(temp < nums[j]) {
            nums[j + 1] = nums[j];
        }
        else break;
    }
    a[j + 1] = temp;
}
```

##### 题解

###### Luogu1271

使用计数排序

```c++
#include <iostream>
using namespace std;
int nums[1050];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n = 0, m = 0;
    cin >> n >> m;
    for(int i = 0; i < m; i++) {
        int temp = 0;
        cin >> temp;
        nums[temp]++;
    }
    for(int i = 1; i <= n; i++) {
        while(nums[i] > 0) {
            cout << i << " ";
            nums[i]--;
        }
    }
    return 0;
}
```

###### Luogu1923

**注意：**直接使用sort函数，再输出nums[k], 会超时。即使有重复数字也不会影响答案。

**解法1：快排的思想**

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int nums[5000050];
int n;
int k;
void qsort(int left, int right) {
    int l = left, r = right, flag = nums[(left + right) / 2];
  
    do{
        while(nums[l] < flag) {
            l++;
        }
        while(nums[r] > flag) {
            r--;
        }
        if(l <= r) {
            swap(nums[l], nums[r]);
            l++, r--;
        }
    } while(l <= r);
    
    if(k <= r ) qsort(left, r);
    else if(k >= l) qsort(l, right);
    else {
       return;
    }

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    qsort(0, n - 1);
    cout << nums[k];
    return 0;
}
```

**解法2：使用nth_element库函数**

```c++
//AC代码：
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N=5e6+100;
int a[N];
int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++) scanf("%d",&a[i]);
    nth_element(a,a+k,a+n);   
    printf("%d\n",a[k]);
    return 0;
}

```

###### Luogu1059

使用库函数实现

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n;
int nums[105];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    sort(nums, nums + n);
    int count = unique(nums, nums + n) - nums;
    cout << count << endl;
    for(int i = 0; i < count; i++) {
        cout << nums[i] << " ";
    }

    return 0;
}
```

###### Luogu1104

sort函数排序：如果返回true那么，第一个参数放在前面，如果返回false，第一个参数放在后面。

对于后输入先输出，可以增加一个变量level。

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n;
struct Student {
    char name[25];
    int year;
    int month;
    int day;
    int level;
    
};
bool cmp(const Student& one, const Student& two) {
    if(one.year < two.year) {
        return true;
    }
    else if(one.year > two.year) {
        return false;
    }
    else {
        if(one.month < two.month) {
            return true;
        }
        else if(one.month > two.month) {
            return false;
        }
        else {
            if(one.day < two.day) {
                return true;
            }
            else if(one.day > two.day) {
                return false;
            }
            else {
                if(one.level > two.level) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    Student stu[100];
    for(int i = 0; i < n; i++) {
        cin >> stu[i].name >> stu[i].year >> stu[i].month >> stu[i].day;
        stu[i].level = i;
    }
    sort(stu, stu + n, cmp);

    for(int i = 0; i < n; i++) {
        cout << stu[i].name << endl;
    }

    return 0;
}
```

###### Luogu1012

注意看比较规则的代码，若一个字符串s包含另一个t，那么需要考虑长串的s[t.size()] 与t[0]比较

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n;
string nums[20];
bool cmp(const string& one, const string& two) {
    int len1 = one.size();
    int len2 = two.size();
    int i = 0;
    for(i = 0; i < min(len1, len2); i++) {
        if(one[i] > two[i]) return true;
        else if(one[i] < two[i]) return false;
    }
    if(len1 == len2) {
        return true;
    }
    else if(len1 > len2) {
        return one[i] > two[0]; 
    }
    else {
        return two[i] < one[0];
    }

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    sort(nums, nums + n, cmp);

    for(int i = 0; i < n; i++) {
        cout << nums[i];
    }

    return 0;
}
```

