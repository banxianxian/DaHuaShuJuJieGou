<div align=center><font size=7>贪心</font></div>

[TOC]

##### 贪心证明方法

1. 反证法
2. 数学归纳法
3. 如果无法严格证明，尝试举出反例，如果没有举出，可以尝试贪心。同时可以利用暴力写出程序，运行数据，观察贪心与暴力结果是否相同

##### 解决的基类基本问题

1. 部分背包问题
2. 选取尽可能多的不相交区间
3. huffman编码

##### memset(void \*str, int c, size_t n)函数使用

对于传入**c**，截取补码的后8位，将截取的8位填充数组中元素每个字节

```c++
#include <iostream>
#include <cstring>
using namespace std;
int a[10];
int main() {

    memset(a, -1, sizeof(a));       // 输出-1  -1 的补码后8位为1111 1111, 
    memset(a, 0, sizeof(a));        // 输出0    0的补码后8位为 0000 0000
    memset(a, 127, sizeof(a));      // 输出2139062143 接近INT_MAX, 127补码的后8位为0111 1111
                                    // 赋给每个数组元素为0111 1111 0111 1111 0111 1111 0111 1111
    memset(a, 128, sizeof(a));      // 输出-2139062144 接近INT_MIN, 128补码的后8位为1000 0000
                                    // 赋给每个数组元素为1000 0000 1000 0000 1000 0000 1000 0000
    memset(a, 255, sizeof(a));      // 输出-1   255的补码后8位为1111 1111 与-1的后8位相同
    for(int i = 0; i < 10; i++) {
        cout << a[i] << "  ";
    }
    return 0;
}
```

##### 题解

###### Luogu3817

贪心策略：从左向右遍历时，考虑**i** 与 **i-1**，优先减少**i**盒糖果数量。

```c++
#include <iostream>
using namespace std;
int n, x;
typedef long long LL;
LL nums[200005];
LL ans;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> x;
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    for(int i = 1; i <= n - 1; i++) {
        if(nums[i - 1] >= x) {
            ans += (nums[i - 1] + nums[i] - x);
            nums[i] = 0;
        }
        else if(nums[i - 1] + nums[i] > x) {
            ans += (nums[i - 1] + nums[i] - x);
            nums[i] = x - nums[i - 1];
        }
    }
    cout << ans << endl;
    return 0;
}
```

###### Luogu1478

及其简单的**部分背包问题**的贪心解法，使用了计数排序优化

```c++
#include <iostream>
using namespace std;
int n, s, a, b;
int numsy[105];
int ans;
int main() {

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> s;
    cin >> a >> b;
    for(int i = 0; i < n; i++) {
        int x = 0, y = 0;
        cin >> x >> y;
        if(x <= (a + b)) {
            numsy[y]++;
        }
    }

    int temp = 0;
    for(int i = 0; i < 105; i++) {

        if((temp + i * numsy[i]) <= s) {
            temp += i * numsy[i];
            ans += numsy[i];
        }
        else {
            ans += (s - temp) / i;
            break;
        }
    }

    cout << ans << endl;
    return 0;
}
```

###### Luogu1208

及其简单的**部分背包问题**的贪心解法，使用了计数排序优化

```c++
#include <iostream>
using namespace std;
int n, m;
int box[1005];
int ans;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for(int i = 0; i < m; i++) {
        int p = 0, a = 0;
        cin >> p >> a;
        box[p] += a;
    }

    for(int i = 0; i < 1005; i++) {
        if(box[i] == 0) continue;
        if(n >= box[i]) {
            n -= box[i];
            ans += i * box[i];
        }
        else {
            ans += n * i;
            break;
        }   
    }
    cout << ans << endl;
    return 0;
}
```

###### Luogu4995

**贪心证明：**

![](https://github.com/banxianxian/image/blob/main/%E6%B4%9B%E8%B0%B7/Luogu4995%E8%B4%AA%E5%BF%83%E8%AF%81%E6%98%8E.png?raw=true)

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int n;
typedef long long LL;
LL ans;
int nums[305];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    // 从小到大
    sort(nums, nums + n);
    int big = n - 1, small = 0;
    while(small < big) {
        ans += (nums[big] - nums[small]) * (nums[big] - nums[small]);
        ans += (nums[big - 1] - nums[small]) * (nums[big - 1] - nums[small]);
        big--;
        small++;
    }
    ans += nums[n - 1] * nums[n - 1];
    cout << ans << endl;
    return 0;
}
```

###### Luogu1080

本题难度较高，有两个难点：

1. 贪心策略是什么以及证明
2. 高精度/低精度

我在使用贪心，大致猜到了贪心策略，并用**排列枚举**进行了验证。

**注意：** Bigint需要开到4000位才行，3000会不够

**严格的贪心证明:**

[贪心证明](https://www.luogu.com.cn/blog/jpp/solution-p1080)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
struct A {
    int l;
    int r;
};
struct Bigint {
    int nums[4000];
    int len;
    Bigint();
    Bigint(int x);
    Bigint operator+(Bigint one);
    Bigint operator*(int x);
    bool operator>(const Bigint& one);
    Bigint operator/(int x);
    void print();
};
Bigint Bigint::operator*(int x) {
    Bigint c;
    c.len = len;
    for(int i = 1; i <= c.len; i++) {
        c.nums[i] = x * nums[i];
    }
    // 处理进位
    c.len += 11;
    for(int i = 1; i <= c.len; i++) {
        c.nums[i + 1] += c.nums[i] / 10;
        c.nums[i] %= 10;
    }

    for(;c.nums[c.len] == 0;) {
        c.len--;
    }
    return c;
}
Bigint Bigint::operator+(Bigint one) {
    Bigint c;
    c.len = max(len, one.len) + 1;
    for(int i = 1; i <= c.len; i++) {
        c.nums[i] = nums[i] + one.nums[i];
    }

    // 处理进位
    for(int i = 1; i <= c.len; i++) {
        c.nums[i + 1] += c.nums[i] / 10;
        c.nums[i] %= 10;
    }

    // 消去0
    for(;c.nums[c.len] == 0;) {
        c.len--;
    }

    return c;
}
bool Bigint::operator>(const Bigint& one) {
    if(len > one.len) {
        return true;
    }
    else if(len < one.len) {
        return false;
    }
    else {
        for(int i = len; i >= 1; i--) {
            if(nums[i] > one.nums[i]) {
                return true;
            }
            else if(nums[i] < one.nums[i]) {
                return false;
            }
        }
        return true;
    }
}
void Bigint::print() {
    for(int i = len; i >= 1; i--) {
        cout << nums[i];
    }
    cout << endl;
}
Bigint::Bigint() {
    len = 0;
    memset(nums, 0, sizeof(nums));
}
Bigint::Bigint(int x) {
    len = 0;
    memset(nums, 0, sizeof(nums));
    len++;
    while(x != 0) {
        nums[len] = x % 10;
        x /= 10;
        len++;
    }
    len--;
}
Bigint Bigint::operator/(int x) {
    Bigint c;
    c.len = len;
    long long remainder = 0; // 余数
    for (int i = len; i >= 1; i--) {
        long long current = remainder * 10 + nums[i]; // 当前被除数
        c.nums[i] = current / x; // 当前位的商
        remainder = current % x; // 更新余数
    }

    // 消去前导零
    for (; c.len > 1 && c.nums[c.len] == 0; c.len--) {}

    return c;
}

A box[1005];
int n;
typedef long long LL;
Bigint ans(1);
bool cmp(const A& one, const A& two) {
    return one.l * one.r < two.l * two.r;
}
int main() {
    cin >> n;
    for(int i = 0; i < n + 1; i++) {
        cin >> box[i].l >> box[i].r;
    }

    sort(box + 1, box + n + 1, cmp);
   
    ans = 1;
    Bigint min1(0);
    for(int i = 0; i < n; i++) {
       
        ans = ans * box[i].l;
        //min1 = max(ans / box[i + 1].r, min1);
        Bigint temp = ans / box[i + 1].r;
        if(temp > min1) {
            min1 = temp;
        }
    }
    min1.print();

    return 0;
}
```

