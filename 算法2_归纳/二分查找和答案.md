<div align=center><font size=7>二分查找和二分答案</font></div>

[TOC]

二分答案有东西没弄明白，对于下面的东西并不一定正确

##### 二分查找

**模板**

数组为**升序**排列

```c++
int nums[n] = {……}
// 查找x，如果有多个重复值，查找下标最大的情况
int bound_find(int x) {
    int l = 0, r = n - 1;
    int ans = 0;
    while(l <= r) {
        int mid = l + (r - l) / 2;
        if(nums[mid] <= x) {
            ans = mid;
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    // 如果没有查找到，nums[ans] < x且nums[ans + 1] > x
    if(nums[ans] != x) {
        return -1;
    }
    return ans;
}

// 查找x，如果有多个重复值，查找下标最小的情况
int bound_find(int x) {
    int l = 0, r = n - 1;
    int ans = 0;
    while(l <= r) {
        int mid = l + (r - l) / 2;
        if(nums[mid] >= x) {
            ans = mid;
            r = mid - 1;
        }
        else {
            l = mid + 1;
        }
    }
    // 如果没有查找到，nums[ans] > x 并且 nums[ans - 1] < x
    if(nums[ans] != x) {
        return -1;
    }
    return ans;
}

```



##### 二分答案

**问题特点：**

1. 有界
2. 单调
3. 问题一般具有这类字眼**“最大的最小”**，**“最小的最大”**，**“最大距离最小”**，**“最小距离最大”**

**问题分类：**

1. 整数的二分答案
2. 实数的二分答案（应该确定精度）

**思考问题思路：**

最好先从暴力的角度出发，当假定答案是mid时，你会怎么判断它是否满足题目条件，如果满足，确定应该向左区间寻找答案还是右区间寻找答案，如果不满足，取满足时的相反区间。

**讨论一个问题：** 没有完全想明白这个东西

比如我们在[0, 10]这个区间上面寻找一个满足条件的最优解，里面可能有多个解满足条件，比如：

```c++
0	1	3	4	5	6	7	8	9
f	t	f	t	t	f	f	f	f
```

如果我们是要寻找最大的解，那么为**5**，5的**右区间**一定是不成立的解，左区间（包括5）一定有成立解

如果我们是要寻找最小的解，那么为**1**，1的**左区间**一定是不成立的解，右区间（包括1）一定有成立解

比如当我们在查找一个最大解是，如果mid是一个可行解，我们自然会去尝试mid的右区间有没有成立的解（右边解更大，即寻找最优解）。

**整数二分答案模板：**

```c++
int bound_find(int l, int r) {
    int ans = 0, mid = 0;
    while(l <= r) {
        int mid = l + (r - l) / 2;
        if(P(mid)) {
            ans = mid;
            r = mid - 1;	// 根据情况这放r或者l
        } 
        else {
            l = mid + 1;	// 根据情况确定这放r或者l
        }
    }
    return ans;
}
```



##### lower_bound()和upper_bound()函数

**函数原型：**

lower_bound(begin，end，val)：不破坏原数组，返回一个地址，找到**最靠前**的为val的地址并返回。

upper_bound(begin，end，val)：不破坏原数组，返回一个地址，找到**最靠后**的为val的地址并返回。

**如果查找不到，均返回大于目标值的值（数组升序排列）**



##### 题解

###### Luogu1678

本题为二分查找，但并非需要对每个数据**b[i]**均在**a[i]**中进行二分查找，而是随着查找的数b[i]变大，在a[i]中的位置相应向后变化，可以维护第一次查找到位置。参考例题Luogu1102。

**注意：**其实对每个b[i]查找也挺好，复杂度为O(mlogn)，用上面的维护思想需要先排序复杂度为O(mlogm + nlogn)

```c++
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
LL ans;
int n, m;
int a[100005];
int b[100005];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> m >> n;
    for(int i = 0; i < m; i++) {
        cin >> a[i];
    }

    for(int j = 0; j < n; j++) {
        cin >> b[j];
    }

    sort(a, a + m);
    sort(b, b + n);
    int index = lower_bound(a, a + m, b[0]) - a;
    
    if(index == m) {
        for(int i = 0; i < n; i++) {
            ans += abs(b[i] - a[m - 1]);
        }
    }
    else {
        
        if(index == 0) {
            LL t1 = ans;
            ans += abs(b[0] - a[0]);
        }
        else {
            LL t1 = ans;
            ans += min(abs(b[0] - a[index]), abs(b[0] - a[index - 1]));
        }
        for(int i = 1; i < n; i++) {
            
            if(index == m) {
                LL t1 = ans;
                ans += abs(b[i] - a[m - 1]);
            }
            else {
                while(index < m && a[index] < b[i]) {
                    index++;
                }
                if(index == 0) {
                    LL t1 = ans;
                    ans += abs(b[i] - a[0]);
                    
                }
                else if(m != index) {
                    LL t1 = ans;
                    ans += min(abs(b[i] - a[index]), abs(b[i] - a[index - 1]));
                }
                else {
                    LL t1 = ans;
                    ans += abs(b[i] - a[m - 1]);
                }
            }
        }

    }
    
    cout << ans << endl;
    return 0;
}
```

###### Luogu2678

本题为二分答案。

构造条件：可以移除<=M个石头，使得选手跳跃的最短距离不超过x。

分析知道：如果题目有解，一定存在一个分界线ans，

当x > ans时，不存在这样的方案。

当x <= ans时，至少存在一种这样的方案（ans一定成立）。

```c++
#include <iostream>
using namespace std;
int L, N, M;
int dis[50005];
int min1 = 50005;
bool P(int x) {
    int cnt = 0;
    int last = dis[0];
    for(int i = 1; i <= N + 1; i++) {
        if(dis[i] - last >= x) {
            last = dis[i];
        } else {
            cnt++;
        }
     }
     return cnt <= M;
}
int bound_find() {
    int l = 0, r = L;
    int mid = 0, ans = 0;
    while(l <= r) {
        mid = l + (r - l) / 2;
        if(P(mid)) {
            ans = mid;
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> L >> N >> M;
    for(int i = 1; i <= N; i++) {
        cin >> dis[i];
        min1 = min(min1, dis[i] - dis[i - 1]);
    }
    dis[N + 1] = L;

    cout << bound_find();

    return 0;
}
```

###### Luogu1163

本题为实数二分。

**注意：答案的值不是【0，1】，而可能大于1**

```c++
#include <iostream>
#include <iomanip>
using namespace std;
int w0, w, m;
const double efs = 1e-4;
bool P(double x) {
    double result = 0;
    double temp = w;
    double a = 1 / (1 + x);
    for(int i = 1; i <= m; i++) {
        temp *= a;
        result += temp;
    }
    //cout << result << endl;
    if(result >= w0) {
        return true;
    }
    else {
        return false;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> w0 >> w >> m;
    double mid = 0, ans = 0;
    double l = 0, r = 5;
    while(r - l > efs) {
        mid = (l + r) / 2;
        if(P(mid)) {
            ans = mid;
            l = mid;
        }
        else {
            r = mid;
        }
    }
    ans *= 100;
    cout << fixed << setprecision(1) << ans << endl;
    return 0;
}
```

###### Luogu3853

**本题为二分答案**

貌似可以使用贪心解决，没有尝试过

**如果一个“空旷指数”成立，那么可能存在比它更小的解，但如果一个“空旷指数”不成立，那么答案只能比该值更大**

**注意：对于答案为1需要特判**

```c++
#include <iostream>
using namespace std;
int L, N, K;
int nums[100005];
bool P(int x) {
    int last = nums[0];
    int cnt = 0;
    for(int i = 1; i < N; i++) {
        if(nums[i] - last <= x) {
            last = nums[i];
        }
        else {
            cnt++;
            last = last + x;
            i--;
        }
    }

    return cnt <= K;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> L >> N >> K;
    for(int i = 0; i < N; i++) {
        cin >> nums[i];
    }
    int l = 0, r = L;
    int ans = 0, mid = 0;
    if(N + K >= L + 1) {
        ans = 1;
    }
    else {
        while (l <= r) {
            mid = (r + l) >> 1;
            if(P(mid)) {
                ans = mid;
                r = mid - 1;
            }
            else {
                l = mid + 1;
            }
        }
    }
   
    cout << ans << endl;

    return 0;
}
```

