<div align=center><font size=7>图</font></div>

[TOC]



##### 图

###### 图论基本概念

省略



###### 图的存储方法和遍历方法

**邻接矩阵：**

比较简单省略。



**邻接表：**

```c++
#include  <iostream>
#include <vector>
#define MAXN 1005
using namespace std;
struct edge {
    int to;		// 终点
    int cost;	// 权值
}
vector<edge> p[MAXN];	// 邻接表
int n, m;				// 记录点数和边数
int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        int u, v, l;		// 起点，终点，权值
        cin >> u >> v >> l;
        p[u].push_back((edge){v, l});
        // 如果是无向图
        p[v].push_back((edge){u, l});
    }
}

```

**两种存储方式的比较：**

邻接表的存储节省空间，邻接矩阵的存储访问的时间复杂度更低。

|            | 邻接表 | 邻接矩阵 |
| ---------- | ------ | -------- |
| 时间复杂度 | O(n)   | O(1)     |
| 空间复杂度 | O(m)   | O(m*n)   |



**深度优先遍历：**

```c++
vector<int> p[maxn];		// 邻接表
bool isVis[maxn];			// 标记是否访问过
void dfs(int x) {
    for(int i = 0; i < p[x].size(); i++) {
        if(!isVis[p[x][i]]) {
            p[x][i] = true;
            dfs(p[x][i]);
        }
    }
}
```

**广度优先遍历：**





###### DAG和拓扑排序

**DAG**：指的是有向无环(圈)图

**拓扑排序**：拓扑排序并不是对一个数列进行排序，而是对**DAG上的点**进行排序，使得搜索到点x时，所有能到达x的点均已经被搜索过了

流程：

1. 将所有入度为0的点加入处理队列
2. 将处于队头的点x取出，遍历x能到达的所有点y
3. 对于每一个y，删去从x到y的边，<u>将y的入度-1即可</u>
4. 如果y的入度减到0，说明所有到达y的点都被计算过，将y加入队列
5. 重复2-4直到队列为空

**具体用途：**

> 可以判断是否存在环



如果需要确定该拓扑排序是否具有唯一的拓扑顺序，可以看代码`//* `标记的位置

```c++
#include <bits/stdc++.h>
using namespace std;
int ind[MAXN];		// 记录入度
int outd[MAXN];		// 记录出度
vector<int> p[MAXN];
int main() {
    /*
    	将图读入
    */
    // 拓扑排序
    //* int depth = 0;
    //* bool status = false;
    queue<int> Q;
	for(int i = 0; i < n; i++) {
        if(ind[i] == 0) Q.push[i]; //* depth++;
    }
    vector<int> ans;	//记录排序的顶点顺序
    while(!Q.empty()) {
        int x = Q.front();
        Q.pop();
        ans.push_back(x);
        //* status = false;
        for(int j = 0; j < p[x].size(); j++) {
            int t = p[x][j];	// 关联的点
            ind[t]--;			// 不需要处理出度
            if(ind[t] == 0) Q.push(t);
            //* if(ind[t] == 0 && !status) depth++, staut = true;
        }
    }
    
    if(ans.size() == n) cout << "无环" << endl;
    else cout << "有环" << endl;
    
    //* if(depth == n) cout << "具有稳定的拓扑顺序" << endl;
}

```



###### 染色法

额外介绍染色法。

**作用：**判断图中是否存在奇数圈（二分图的判断定理）

**模板：**

```c++
#include <bits/stdc++.h>
using namespace std;
vector<int> p[maxn];
int color[maxn];	// 0代表没有访问过，1代表一种染色，2代表另外一种染色
int n, m;			// n代表节点个数
int main() {
    
    queue<int> Q;
    // 外层循环是为了解决多个连通分支的情况
    for(int i = 1; i <= n; i++) {
        if(!color[i]) {
            color[i] = 1;
            Q.push(i);
        }
        
        while(!Q.empty()) {
            int t = Q.front();
            Q.pop();
            for(int i = 0; i < p[t].size(); i++) {
                int temp = p[t][i];
                if(color[temp] == color[t]) {
                    cout << "不是二部图" << endl;
                    exit(0);
                }
                else if(color[t] == 1 && color[temp] == 0) {
                    color[temp] = 2;
                    Q.push(temp);
                }
                else if(color[t] == 2 && color[temp] == 0) {
                    color[temp] = 1;
                    Q.push(temp);
                }
            }
        }
	}
    
    
    return 0;
}
```



##### 题解

###### Luogu3916

有两个重要的思路：

1. 反向建图
2. 优化遍历：不是简单对每个顶点使用搜索，而是在一次搜索中完成任务

```c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
int N, M;
// 记录答案的数组
int a[100005];
vector<int> q[100005];      // 邻接表
bool isVis[100005];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N >> M;
    for(int i = 0; i < M; i++) {
        int tempx, tempy;
        cin >> tempx >> tempy;
        // 构造反向边
        q[tempy].push_back(tempx);
    }

    queue<int> Q;
    for(int i = N; i >= 1; i--) {
        if(!isVis[i]) Q.push(i);
        
        while(!Q.empty()) {
            int x = Q.front();
            Q.pop();
            isVis[x] = true;
            a[x] = i;

            // 遍历所有关联的点
            for(int j = 0; j < q[x].size(); j++) {
                int t = q[x][j];
                if(!isVis[t]) {
                    Q.push(t);
                }
            }
        }
    }

    for(int i = 1; i <= N; i++) {
        cout << a[i] << " ";
    }

    return 0;
}
```



###### leetcode207

本题可以转换为一个DAG中是否存在圈，如果存在圈则无法学完，反之，则可以。

之后使用拓扑排序检测是否存在圈即可.

```c++
class Solution {
public:
    int ind[2005];
    int outd[2005];
    vector<int> p[2005];
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        int ans = 0;
        // 读入图
        for(int i = 0; i < prerequisites.size(); i++) {
            int x = prerequisites[i][0];
            int y = prerequisites[i][1];
            p[y].push_back(x);
            ind[x]++; 
            outd[y]++; 
        }

        // 进行拓扑排序
        queue<int> Q;
        for(int i = 0; i < numCourses; i++) {
            if(ind[i] == 0) Q.push(i);
        }

        while(!Q.empty()) {
            int x = Q.front();
            Q.pop();
            ans++;
            for(int i = 0; i < p[x].size(); i++) {
                int t = p[x][i];
                ind[t]--;
                if(ind[t] == 0) Q.push(t);
            }
        }

        if(ans == numCourses) return true;
        return false;
    }
};
```

###### leetcode210

本题与上面一题是一样的，只需要额外记录拓扑排序的顺序即可

```c++
class Solution {
public:
    int ind[2005];
    int outd[2005];
    vector<int> p[2005];
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> ans;
        // 读入图
        for(int i = 0; i < prerequisites.size(); i++) {
            int x = prerequisites[i][0];
            int y = prerequisites[i][1];
            p[y].push_back(x);
            ind[x]++; 
            outd[y]++; 
        }

        // 进行拓扑排序
        queue<int> Q;
        for(int i = 0; i < numCourses; i++) {
            if(ind[i] == 0) Q.push(i);
        }

        while(!Q.empty()) {
            int x = Q.front();
            Q.pop();
            ans.push_back(x);
            for(int i = 0; i < p[x].size(); i++) {
                int t = p[x][i];
                ind[t]--;
                if(ind[t] == 0) Q.push(t);
            }
        }

        if(ans.size() == numCourses) return ans;
        return vector<int>();
    }
};

```

###### Luogu2661

思路：本题可以转换为一个DAG图，然后查找最短的圈（环），有一个重点`一个连通分支一定最多只有一个圈`。

查找最短圈的思路为先使用拓扑排序将非圈的点去除，然后使用dfs进行遍历（每个点最多只有一个出度）

```c++
// 构造成一个DGA，然后查找最短的圈
// 本题的DAG一定为链与一个环(圈)组合成，
#include <iostream>
#include <queue>
#include <climits>
using namespace std;
int n;
int ind[200005];
int outd[200005];
vector<int> p[200005];
int isVis[200005];
int dfs(int x) {
    
    if(isVis[x]) {
        return 0;
    }
    
    isVis[x] = true;
    return dfs(p[x][0]) + 1;
}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    for(int i = 1; i <= n; i++) {
        int j = 0;
        cin >> j;
        p[i].push_back(j);
        ind[j]++;
        outd[i]++;
    }

    // 可能存在多个连通分支，于是先使用拓扑排序将链全部去除，然后再用dfs遍历
    queue<int> Q;
    for(int i = 1; i <= n; i++) {
        if(ind[i] == 0) Q.push(i);
    }

    while(!Q.empty()) {
        int x = Q.front();
        Q.pop();
        isVis[x] = true;
        for(int i = 0; i < p[x].size(); i++) {
            int t = p[x][i];
            ind[t]--;
            if(ind[t] == 0) Q.push(t);
        }

    }

    // 剩下部分为多个环
    int min1 = INT_MAX;
    for(int i = 1; i <= n; i++) {
        if(!isVis[i]) {
            min1 = min(dfs(i), min1);
            
        }
    }

    cout << min1 << endl;
    return 0;
}
```



###### Luogu1807

思路：

1. 使用一次dfs()判断1与n是否是连通的
2. 通过第一次拓扑排序，将不是从1出发的路去除
3. 再通过一次拓扑排序，得到从1出发到n的路的长度

```c++
// 拓扑排序
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1550;
struct edge {
    int to;
    int weight;
};
int ind[maxn];
int outcome[maxn];
vector<edge> p[maxn];
bool isVis[maxn];
int n, m;
void dfs(int x) {
    isVis[x] = true;
    for(int i = 0; i < p[x].size(); i++) {
        if(!isVis[p[x][i].to]) dfs(p[x][i].to);
    }
}
int main() {
    int first;
    memset(outcome, 128, sizeof(outcome));
    cin >> n >> m;
    int u, v, we;
    for(int i = 0; i < m; i++) {
        cin >> u >> v >> we;
        if(i == 0) first = u;
        p[u].push_back(edge{v, we});
        ind[v]++;
    }


    
    // 判断1是否和n在同一个连通分支内
    dfs(1);
  

    // 拓扑排序
    if(isVis[n]) {
        // 去除不是从1出发的到n的路
        // 做法：不将1加入Q中
        queue<int> Q;
        for(int i = 2; i <= n; i++) {
            if(ind[i] == 0) {
                Q.push(i);
                outcome[i] = 0;
            }
        }

        while(!Q.empty()) {
            int x = Q.front();
            Q.pop();
            for(int i = 0; i < p[x].size(); i++) {
                int t = p[x][i].to;
                int we = p[x][i].weight;
                ind[t]--;
                if(ind[t] == 0) Q.push(t);
            }
        }


        // 将1加入Q中，查找从1到n的路
        Q.push(1);
        outcome[1] = 0;
        while(!Q.empty()) {
            int x = Q.front();
            Q.pop();
            for(int i = 0; i < p[x].size(); i++) {
                int t = p[x][i].to;
                int we = p[x][i].weight;
                outcome[t] = max(outcome[x] + we, outcome[t]);
                ind[t]--;
                if(ind[t] == 0) Q.push(t);
            }
        }

        cout << outcome[n] << endl;

    }
    else {
        cout << "-1" << endl;
    }
    
    
    return 0;
}
```



###### Luogu2853

**思路：** 首先得到牛所在的牧场（点），然后对这些点一次进行dfs，将其能到的点+1（有一个数组记录）, 如果最后1- N的点ans[i] == 牛所在牧场的个数，那么这个牧场就是满足条件的

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <cstring>
using namespace std;
int K, N, M;
vector<int> p[1005];      // 邻接表
unordered_set<int> box1;
int ans[1005];
bool isVis[1005];
void dfs(int x) {
    for(int i = 0; i < p[x].size(); i++) {
        if(!isVis[p[x][i]]) {
            isVis[p[x][i]] = true;
            ans[p[x][i]]++;
            dfs(p[x][i]);
        }

    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    // 读入数据
    cin >> K >> N >> M;
    for(int i = 0; i < K; i++) {
        int temp;
        cin >> temp;
        box1.insert(temp);
    }
    
    for(int i = 0; i < M; i++) {
        int x, y;
        cin >> x >> y;
        p[x].push_back(y);
    }

    for(auto it = box1.begin(); it != box1.end(); it++) {
        int node = *it;
        memset(isVis, 0, sizeof(isVis));
        ans[node]++;
        isVis[node] = true;
        dfs(node);
    }

    int cnt = 0;
    for(int i = 1; i <= N; i++) {
        if(ans[i] == box1.size()) {
            cnt++;
        }
    }

    cout << cnt << endl;

    return 0;
}
```

###### Luogu1330

**思路：**

我最开始只想到`如果图中存在奇圈，那么一定是impossible`，然后就不知道怎么求

其实每个点只有两种状态：有螃蟹或者没有螃蟹，并且一条边的两个点颜色一定不同，那么使用染色法，如果该连通分支可以成功染色那么该分支需要的螃蟹为最小的那种颜色个数，如果存在奇圈则不存在方案

```c++
#include <bits/stdc++.h>
using namespace std;
int n, e;
vector<int> p[10005];
int color[10005];   // = 0 代表没有访问过, = 1 代表一种染色, = 2 代表另外一种染色
int main() {

    // 读入数据
    cin >> n >> e;
    for(int i = 0; i < e; i++) {
        int tempx, tempy;
        cin >> tempx >> tempy;
        p[tempx].push_back(tempy);
        p[tempy].push_back(tempx);
    }

    // 进行染色
    int ans = 0;
    queue<int> Q;
    for(int i = 1; i <= n; i++) {
        int num1 = 0, num2 = 0;
        if(!color[i]) {
            color[i] = 1;
            num1++;
            Q.push(i);
        }
        
        while(!Q.empty()) {
            int t = Q.front();
            Q.pop();
            for(int i = 0; i < p[t].size(); i++) {
                int temp = p[t][i];
                if(color[temp] == color[t]) {
                    cout << "Impossible" << endl;
                    exit(0);
                }
                else if(color[t] == 1 && color[temp] == 0) {
                    color[temp] = 2;
                    num2++;
                    Q.push(temp);
                }
                else if(color[t] == 2 && color[temp] == 0) {
                    num1++;
                    color[temp] = 1;
                    Q.push(temp);
                }

            }
        }

        ans += min(num1, num2);

    }

    cout << ans << endl;

    return 0;
}
```



###### Luogu1127

**思路：** 先构建DAG图，然后进行dfs查找一条回路（首先需要对字符串排序，为了保证按字典序输出），但是会出现两个点无法通过，原因在于遍历dfs是从**每个点出发查找了一次**，但是出发字符串的首字母一定只在字符串首与尾出现奇数次。

好像有欧拉回路的解法，暂不考虑

```c++
// 需要判断是否连通
#include <bits/stdc++.h>
using namespace std;
int n;
vector<string> box;

vector<int> pre[26];
vector<int> last[26];

vector<int> p[1005];
vector<int> ans;
int isVis[1005];
bool cmp(const string& one, const string& two) {
    int t = one.compare(two);
    if(t > 0) return false;
    return true;
}


void dfs(int x, int depth, vector<int> t) {
    if(depth == n) {
        //cout << "n=" << n << endl;
        /*for(auto it : t) {
            cout << box[it] << ".";
        }*/
        for(int i = 0; i < t.size(); i++) {
            if(i != t.size() - 1) cout << box[t[i]] << ".";
            else cout << box[t[i]];
        }
        exit(0);
    }
    
    for(int i = 0; i < p[x].size(); i++) {
        int t1 = p[x][i];
        if(!isVis[t1]) {
            t.push_back(t1);
            isVis[t1] = true;
            dfs(t1, depth + 1, t);
            t.pop_back();
            isVis[t1] = false;
        }
    }
}


int main() {

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin >> n;
    for(int i = 0; i < n; i++) {
        string temp;
        cin >> temp;
        box.push_back(temp);
        
    }

    sort(box.begin(), box.end(), cmp);

    for(int i = 0; i < n; i++) {
        string temp = box[i];
        int pre1 = temp[0] - 'a';
        int last1 = temp[temp.size() - 1] - 'a';
        pre[pre1].push_back(i);
        last[last1].push_back(i);
    }


    // 构建DAG
    for(int i = 0; i < 26; i++) {
        if(pre[i].size() != 0 && last[i].size() != 0) {
            for(int j = 0; j < pre[i].size(); j++) {
                for(int k = 0; k < last[i].size(); k++) {
                    int pre1 = pre[i][j];
                    int last1 = last[i][k];
                    if(pre1 != last1) {
                        p[last1].push_back(pre1);
                    }
                }
            }
        }
    }


    // 优化部分
    vector<int> pans;
    int nums[26] = {0};

    for(int i = 0; i < 26; i++) {
        nums[i] = pre[i].size() + last[i].size();
        if(nums[i] % 2 != 0) {
            for(int j = 0; j < pre[i].size(); j++) {
                pans.push_back(pre[i][j]);
            }
        }
    }

    // 使用dfs()按照字典序遍历
    if(pans.size() != 0) {
        for(int i = 0; i < pans.size(); i++) {
            memset(isVis, 0, sizeof(isVis));
            isVis[pans[i]] =true;
            dfs(pans[i], 1, vector<int>({pans[i]}));
        }
    }
    else {
        for(int i = 0; i < n; i++) {
            memset(isVis, 0, sizeof(isVis));
            isVis[i] =true;
            dfs(i, 1, vector<int>({i}));
        }
    }

    

    cout << "***" << endl;
    return 0;
}
```



###### Luogu1347

注意：在想到使用拓扑排序后，并且考虑了圈，需要考虑拓扑排序是否只有一种方式（具有稳定的拓扑顺序），否则也是无法得到正确的解的，注意代码47，52，64的作用depth.

```c++
#include <iostream>
#include <set>
#include <vector>
#include <queue>
#include <unordered_set>
using namespace std;
int n,m;
vector<int> p[26];
int ind[26];
int oud[26];
int main() {

    ios::sync_with_stdio(false);
    cout.tie(0), cin.tie(0);

    cin >> n >> m;
    vector<string> box;
    unordered_set<string> box2;
    for(int i = 0; i < m; i++) {
        string temp;
        cin >> temp;
        box.push_back(temp);
    }

    // 开始构建图以及进行拓扑排序
    for(int i = 0; i < box.size(); i++) {
        if(box2.find(box[i]) != box2.end()) continue;
        box2.insert(box[i]);
        string one = box[i];
        int x = one[0] - 'A';
        int y = one[2] - 'A';
        
        p[x].push_back(y);
        ind[y]++;
        oud[x]++;

        vector<int> tempP[26];
        int tempInd[26] = {0};
        int tempOud[26] = {0};
        for(int j = 0; j < 26; j++) tempP[j] = p[j], tempInd[j] = ind[j], tempOud[j] = oud[j];
        
        // 进行拓扑排序
        
        int zero_num = 0;
        int zero_num_to = 0;
        bool status = false;        // 用于判断是否具有稳定的拓扑排序结果
        int depth = 0;

        queue<int> Q;
        vector<int> ans;
        for(int j = 0; j < n; j++) {
            if(ind[j] == 0) {Q.push(j); zero_num++; depth++;}
            else if(tempOud[j] == 0) {zero_num_to++;}
        }

        while(!Q.empty()) {
            int x = Q.front();
            Q.pop();
            ans.push_back(x);
            status = false;
            for(int j = 0; j < tempP[x].size(); j++) {
                tempInd[tempP[x][j]]--;
                if(tempInd[tempP[x][j]] == 0) Q.push(tempP[x][j]);
                if(tempInd[tempP[x][j]] == 0 && !status) depth++, status = true;
            }
        }

        if(ans.size() == n && zero_num == 1 && zero_num_to == 1 && depth == n) {
            cout << "Sorted sequence determined after " << i + 1 <<" relations: ";
            for(int j = 0; j < ans.size(); j++) cout << char(ans[j] + 'A');
            cout << "." << endl;
            exit(0);
        }
        else if(ans.size() != n) {
            cout << "Inconsistency found after " << i + 1 << " relations." << endl;
            exit(0);
        }
    }

    cout << "Sorted sequence cannot be determined." << endl;

    return 0;
}
```

