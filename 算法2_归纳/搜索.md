<div align=center><font size=7>搜索</font></div>



[TOC]

##### 深度优先搜索

对于n个顶点的图，搜索的复杂度为O(n)

**解决的问题：**

1. 排列枚举（枚举需要生成排列再判断，而搜索只需要一个一个填再判断）
2. 子集枚举（回溯中选与不选）
3. 字典序最小的解
4. 查找连通块

**模板**

其实也是回溯模板，回溯问题可以用全局变量接受结果，但对于记忆化搜索（转递推问题）需要返回解。

```c++
void dfs(int k) {
    if(满足结束条件) {
        // 判断是否需要更新答案
        return；
    }
    for(枚举所有可能) {
        if(选项合法) {
            记录该选项（保存现场）
                dfs(k + 1);
            取消该答案（恢复现场）
        }
    }
    
}
```

##### 广度优先搜索

对于n个顶点的图，搜索的复杂度为O(n)

**解决的问题：**

1. 查找步骤最小的解：**是否可以用记录步数的数组来标记是否走过，还是需要具体分析的。**

1. 查找连通块

**模板**

```c++
Q.push(初始状态)
    while(!Q.empty()) {
        u = Q.front();
        Q.pop();
        for(枚举全部可以扩展的状态) {
            if(状态v满足要求) {
                Q.push(v);
            }
		}
    }
```



##### 折半搜索

**做法**

将一个搜索区间分为两部分，分别搜索前半部分，并用`unordered_map`存储前半部分的结果，在搜索后半部分内容

**时间复杂度分析：**

假定每个搜索有三种可能性，未使用折半搜索，O($3^n$)，使用折半搜索O($3^{\frac{n}{2}}$ + $3^\frac{n}{2}$) = O($2\times 3^\frac{n}{2}$)

**模板：**

```c++
#include <bits/stdc++.h>
using namespace std;
int n, m;					// n为搜索对象个数，m为需要搜索到的值的和
int nums[50];			// 搜索的对象
int ans = 1e9;
unordered_map<int, int> h;
// 前半部分搜索[0, n / 2]
void dfs1(/*需要传入的参数与dfs2相同*/) {
	 
	if(/*满足某种条件*/) {
        //更新答案
    }
    else {
        // 到达n/2 边界，使用h记录答案
        if(h.count(/*判断是否已经记录过，如果记录过更新答案*/)) {
            h[] = min/max(h[], /**/)
        }
    }
	
    // 可能有多种情况，按照搜索逻辑写即可
	// 一种情况
	dfs1(/***/);
	// 两种情况
	dfs1(/***/);
	 
	
}
// 后半部分搜索(n/2, n)
void dfs2(/**/) {
	if(/*满足某种条件*/) {
        //更新答案
    }
    else {
        // 到达n/2 边界，使用h记录答案
        if(h[]) {
            
        }
    }
	
	// 可能有多种情况，按照搜索逻辑写即可
	// 一种情况
	dfs2(/***/);
	// 两种情况
	dfs2(/***/);
	
}
int main() {
	// 对数据乘2之后，再除的时候可以避免出现分数 
	dfs1(0, 0, 0);
	dfs2(n / 2 , 0, 0);
	return 0;
}
```



##### stl知识

万能头文件`#include <bits/stdc++.h>`

**缺点：** 会导致命名空间被污染



##### 题解

###### Luogu1036

子集型枚举（选与不选），使用深度优先搜索实现

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
int nums[15][2];
int min1 = 1e9;
int d;
int acid = 1;
int ku;
void dfs(int k, int t) {
    if(k >= n && t > 0) {
        min1 = min(min1, abs(acid - ku));
        return;
    } 
    else if(k >= n) {
        return;
    }

    // 加入
    acid *= nums[k][0];
    ku += nums[k][1];
    dfs(k + 1, t + 1);
    acid /= nums[k][0];
    ku -= nums[k][1];
    // 不加入
    dfs(k + 1, t);
}
int main() {

    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> nums[i][0] >> nums[i][1];
    }

    dfs(0, 0);
    cout << min1 << endl;

    return 0;
}
```

###### Luogu1605

**注意：** 题目所说的每个方格最多只经过一次，指的是每条路上每个方格只允许经过一次，并非所以路合起来只允许经过一次。

本题广度优先搜索也可以实现，需要产生多个新地图去记录。

```c++
#include <bits/stdc++.h>
using namespace std;
int N, M, T;
int move1[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
int sx, sy, fx, fy;
int ok[8][8];
int ans;
void dfs(int x, int y) {
    if(x == fx && y == fy) {
        ans++;
        return;
    }
    
    ok[x][y] = 1;   // 表示走过
    for(int i = 0; i < 4; i++) {
        int tempx = x + move1[i][0], tempy = y + move1[i][1];
        if(tempx >= 1 && tempx <= N && tempy >= 1 && tempy <= M && ok[tempx][tempy] == -1) {
            dfs(tempx, tempy);
        }
    }
    ok[x][y] = -1;

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    memset(ok, -1, sizeof(ok));
    cin >> N >> M >> T;
    cin >> sx >> sy >> fx >> fy;
    for(int i = 0; i < T; i++) {
        int tempx = 0, tempy = 0;
        cin >> tempx >> tempy;
        ok[tempx][tempy] = 1;
    }
    dfs(sx, sy);
    cout << ans << endl;
    return 0;
}
```

###### Luogu1019

子集型枚举（选与不选），使用深度优先搜索实现。每个单词可以选择两次，当作两个单词操作即可。

**注意：** 如果两个拼接单词存在重合部分，应该去最小重合部分

```c++
#include <iostream>
using namespace std;
typedef long long LL;
LL maxL;
int n;
string ch;
string s[25];
int nums[25];
void dfs(string t) {
    // if(t.size() > 20) cout << t << endl;
    maxL = max(maxL, (LL)t.size());

    for(int i = 0; i < n; i++) {
        if(nums[i] < 2) {
            for(int j = t.size() - 1; j >= 0; j--) {
                int pre = j;
                int lat = 0;
                while(pre < t.size() && lat < s[i].size() && t[pre] == s[i][lat]) {
                    pre++;
                    lat++;
                }
                if(pre == t.size() && lat != s[i].size()) {
                    // 获取新的字符串
                    string temp = t;
                    t = t + s[i].substr(lat);
                    nums[i]++;
                    dfs(t);
                    nums[i]--;
                    t = temp;
                    break;
                }
            }
            

        }
    }

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> s[i];
    }
    cin >> ch;
    dfs(ch);
    cout << maxL << endl;
    return 0;
}
```

###### Luogu1101

**本题没质量，搜索y判断即可**

```c++
#include <bits/stdc++.h>
using namespace std;
int n;
string s[105];
string tar = "yizhong";
bool nums[105][105];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for(int i = 0; i < n; i++) cin >> s[i];
    // 暴力
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(s[i][j] == 'y') {
                string temp;
                // 处理行
                if(j + 7 <= n) {
                    temp = s[i].substr(j, 7);
                    if(temp == tar) {
                        for(int k = 0; k < 7; k++) nums[i][j + k] = 1;
                    }
                }
                
                if(j - 6 >= 0) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i][j - k] != tar[k]) break;
                    }

                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i][j - p] = 1;
                        }
                    }
                }
                
                // 处理列
                if(i + 7 <= n) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i + k][j] != tar[k]) break;
                    }
                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i + p][j] = 1;
                        }
                    }
                }

                if(i - 6 >= 0) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i - k][j] != tar[k]) break;
                    }
                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i - p][j] = 1;
                        }
                    }
                }

                // 处理对角线
                if(j + 7 <= n && i - 6 >= 0) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i - k][j + k] != tar[k]) break;
                    }
                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i - p][j + p] = 1;
                        }
                    }
                }

                if(j - 6 >= 0 && i - 6 >= 0) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i - k][j - k] != tar[k]) break;
                    }
                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i - p][j - p] = 1;
                        }
                    }
                }

                if(j + 7 <= n && i + 7 <= n) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i + k][j + k] != tar[k]) break;
                    }
                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i + p][j + p] = 1;
                        }
                    }
                }

                if(j - 6 >= 0 && i + 7 <= n) {
                    int k = 0;
                    for(k = 0; k < 7; k++) {
                        if(s[i + k][j - k] != tar[k]) break;
                    }
                    if(k == 7) {
                        for(int p = 0; p < 7; p++) {
                            nums[i + p][j - p] = 1;
                        }
                    }
                }

                
            }
        }
    }

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(nums[i][j] == 1) {
                cout << s[i][j];
            }
            else {
                cout << "*";
            }
        }
        cout << endl;
    }
    return 0;
}
```

###### Luogu2404

本题为dfs解决字典序问题，为了避免重复解，需要记录上次选择的数字。

**注意：** 记得保护现场和恢复现场，本题用临时变量保护，所以不用恢复。

dfs总是没法一次写对

```c++
#include <iostream>
using namespace std;
int n;
void dfs(int t, string s, int pre) {
    if(t == n) {
        cout << s << endl;
        return;
    }
    else if(t > n) return;


    for(int i = max(pre, 1); i <= n - t; i++) {
        if(t + i <= n && i != n) {
            string temp;
            temp = s + to_string(i);
            if(t + i != n) temp = temp + string("+");
            dfs(t + i, temp, i);
        }
    }

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    dfs(0, "", -1);
    

    return 0;
}
```

###### Luogu1596

本题为求解**连通块个数**的问题，使用BFS解决，先暴力找到需要bfs部分，如果bfs即可

```c++
#include <iostream>
#include <queue>
using namespace std;
struct coord {
    int x;
    int y;
};

int N, M;
int ans;
bool visted[105][105];
char field[105][105];
int move1[8][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> N >> M;
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            cin >> field[i][j];

        }
    }


    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            if(field[i][j] == 'W' && visted[i][j] == false) {
                coord t = {i, j};
                queue<coord> Q;
                Q.push(t);
                while(!Q.empty()) {
                    coord now = Q.front();
                    Q.pop();
                    for(int i = 0; i < 8; i++) {
                        int x = now.x + move1[i][0];
                        int y = now.y + move1[i][1];
                        if(x < 0 || x >= N || y < 0 || y >= M || field[x][y] == '.' || visted[x][y]) 
                                                                                            continue;
                        Q.push({x, y});
                        visted[x][y] = true;
                    }
                }
                ans++;
            }
        }
    }

    cout << ans << endl;

    
    return 0;
}
```

###### Luogu1162

其实本题也是连通块，重点在于区分1内部的0，和外部的0，内部0不好直接区分，而**外部的0一定是与边界相邻的**。

```c++
#include <iostream>
#include <queue>
using namespace std;
int n;
int nums[35][35];
bool visted[35][35];
int move1[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
struct coord {
    int x;
    int y;
};
void bfs(int x, int y) {
    queue<coord> Q;
    coord t({x, y});
    Q.push(t);
    while (!Q.empty()) {
        coord now = Q.front();
        Q.pop();
        for(int i = 0; i < 4; i++) {
            int tx = now.x + move1[i][0];
            int ty = now.y + move1[i][1];
            if(tx < 0 || tx >= n || ty < 0 || ty >= n || visted[tx][ty] || nums[tx][ty] == 1) continue;
            visted[tx][ty] = true;
            Q.push({tx, ty});
        }
    }
    
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            cin >> nums[i][j];
        }
    }

    for(int i = 0; i < n; i++) {
        if(nums[0][i] == 0 && !visted[0][i]) bfs(0, i);
        if(nums[n - 1][i] == 0 && !visted[n - 1][i]) bfs(n - 1, i);
    }

   for(int j = 0; j < n; j++) {
        if(nums[j][0] == 0 && !visted[j][0]) bfs(j, 0);
        if(nums[j][n - 1] == 0 && !visted[j][n - 1]) bfs(j, n - 1); 
    }

    
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(nums[i][j] == 0 && !visted[i][j]) {
                cout << "2 ";
            }
            else cout << nums[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

###### Luogu1825

本题用bfs搜索实现，本题挺不错，要注意一下几点：

1. 本题不适合像马的遍历一样用visted记录走到每个点需要步骤来标记是否走过该点，应该再开一个数组记录
2. 注意存在传送门，分析易知传送门只能使用两次，并且每个门进路各一次

**是否可以用记录步数的数组来标记是否走过，还是需要具体分析的。**

```c++
#include <iostream>
#include <cstring>
#include <queue>
#include <fstream>
using namespace std;
struct coord {
    int x;
    int y;
};
int N, M;
int sx, sy;
int fx, fy;
char ch[305][305];
int visted[305][305];
bool isVis[305][305];
int move1[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
coord t[30][2];

void bfs() {
    queue<coord> Q;
    Q.push({sx, sy});
    visted[sx][sy] = 0;
    while(!Q.empty()) {
        coord now = Q.front();
        Q.pop();
        for(int i = 0; i < 4; i++) {
            int x = now.x + move1[i][0];
            int y = now.y + move1[i][1];
            int temp = visted[now.x][now.y];
            if(x < 0 || x >= N || y < 0 || y >= M || isVis[x][y] || ch[x][y] == '#') continue;
            visted[x][y] = min(temp + 1, visted[x][y]);
            isVis[x][y] = true;
            if(0 <= ch[x][y] - 'A' && ch[x][y] - 'A' <= 25) {
                coord a = t[ch[x][y] - 'A'][0];
                coord b = t[ch[x][y] - 'A'][1];
                if(a.x == x && a.y == y) {
                    visted[b.x][b.y] = temp + 1;
                    Q.push(b);
                }
                else {
                    visted[a.x][a.y] = temp + 1;
                    Q.push(a);
                }
            }
            else {
                Q.push({x, y});
            }
            
        }
        
    }

}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    memset(t, -1, sizeof(t));
    memset(visted, 127, sizeof(visted));
    memset(isVis, 0, sizeof(isVis));
    cin >> N >> M;

    for(int i = 0; i < N; i++) {
        for(int j = 0; j < M; j++) {
            cin >> ch[i][j];
            if(0 <= ch[i][j] - 'A' && ch[i][j] - 'A' <= 25) {
                if(t[ch[i][j] - 'A'][0].x == -1) {
                    t[ch[i][j] - 'A'][0] = {i, j};
                }
                else {
                    t[ch[i][j] - 'A'][1] = {i, j};
                }
            }
            else if(ch[i][j] == '@') {
                sx = i;
                sy = j;
            }
            else if(ch[i][j] == '=') {
                fx = i;
                fy = j;
            }
        }
    }

    bfs();
    cout << visted[fx][fy] << endl;
    return 0;
}
```

