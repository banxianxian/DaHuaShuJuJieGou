<div align=center><font size=7>枚举</font></div>

[TOC]

##### 循环枚举

对于该类枚举问题，优化从两个方面考虑：

1. 对于枚举，进行剪枝
2. **更换不同的枚举方式**

对于2举个例子：

> 将1，2……，9共九个数分成三组，分别组成3个三位数，使得三个三位数满足A:B:C

我们可以枚举一个三位数，然后通过比例计算出另外两个三位数，最后判断条件（3个三位数不存在重复数字）是否成立。而不是一开始枚举三个三位数，在判断是否满足条件（A：B：C）。



##### 子集枚举

从一个集合里面选出子集，再判断子集是否满足条件的问题。

n个元素的子集有$2^n$个。

1. 用回溯法枚举
2. 使用2进制表示的数字，进行判断是否出现，可以使用stl中函数**_builtin_popcount()**统计一个数2进制表示1的个数

枚举子集复杂度为：O($2^n$)，**1s可以枚举20-30个元素的集合的子集**



##### 排列枚举

可以使用函数**next_permutation()**得到全排列。

全排列的时间复杂度是O(n!)，**1s很难枚举超过11个元素的全排列**。

##### stl函数使用：

###### _builtin_popcount()

###### next_permutation()



##### 题解

###### Luogu3654

当k=1时需要特判，行列两种方式是一样的。

```c++
// 循环枚举
#include <iostream>
using namespace std;
int R, C, K;
char nums[105][105];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> R >> C >> K;
    for(int i = 0; i < R; i++) {
        for(int j = 0; j < C; j++) {
            cin >> nums[i][j];
        }
    }
    int sum = 0;
    // 行排列
    for(int i = 0; i < R; i++) {
        int count = 0;
        for(int j = 0; j < C; j++) {
            if(nums[i][j] == '.') {
                count++;
                if(j != C - 1) continue;
            }
            
            if(count >= K) {
                sum += count - K + 1;
            }
            if(j + K >= C) {
                break;
            }
            count = 0;
            
        }
    }

    // 列排列
    for(int j = 0; j < C; j++) {
        int count = 0;
        for(int i = 0; i < R; i++) {
            if(nums[i][j] == '.') {
                count++;
                if(i != R - 1) continue; 
            }
            if(count >= K) {
                sum += count - K + 1;
            }
            if(i + K >= R) {
                break;
            }
            count = 0;
        }
    }

    // 1需要特判
    if(K == 1) cout << sum / 2 << endl;
    else cout << sum << endl;

    return 0;
}
```

###### Luogu1217

需要更换枚举方式，直接先构造回文数字（回文数字相对稀疏，3位的回文数字只有90，4位的回文数字90个，5位，6位900个）。

**回文数字比素数稀疏**

**偶数位的回文数字（除11外），一定是11的倍数，即一定不是素数**

```c++
#include <iostream>
using namespace std;
int a, b;
typedef long long LL;
LL count;

bool isPrime(int x) {
    if(x % 2 == 0) return false;
    for(int i = 3; i*i <= x; i += 2) {
        if(x % i == 0) return false; 
    }
    return true;
}
void creatHuiWen(int depth) {
    if(depth == 3) {
        for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                int palindrome = d1 * 100 + d2 * 10 + d1;
                if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                    cout << palindrome << endl;
                    count++;
                }
            }
        }
    }
   
    else if(depth == 5) {
        for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                for(int d3 = 0; d3 <= 9; d3++) {
                    int palindrome = d1 * 10000 + d2 * 1000 + d3 * 100 + d2 * 10 + d1;
                    if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                        cout << palindrome << endl;
                        count++;
                    }
                }
            }
        }
    }

    else if(depth == 7) {
        for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                for(int d3 = 0; d3 <= 9; d3++) {
                    for(int d4 = 0; d4 <= 9; d4++) {
                        int palindrome = d1 * 1000000 + d2 * 100000 + d3 * 10000 + 
                        d4 * 1000 + d3 * 100 + d2 * 10 + d1;
                        if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                            cout << palindrome << endl;
                            count++;
                        }
                    }
                }
            }
        }
    }
    else if(depth == 9) {
         for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                for(int d3 = 0; d3 <= 9; d3++) {
                    for(int d4 = 0; d4 <= 9; d4++) {
                        for(int d5 = 0; d5 <= 9; d5++) {
                            int palindrome = d1 * 100000000 + d2 * 10000000 + d3 * 1000000 + d4 * 100000 + 
                            d5 * 10000 + d4 * 1000 + d3 * 100 + d2 * 10 + d1;
                            if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                                cout << palindrome << endl;
                                count++;
                            }
                        }
                    }
                }
            }
        }
    }
}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> a >> b;
    if(a <= 5 && b >= 5) {
        count++;
        cout << "5" << endl;
    }
    if(a <= 7 && b >= 7) {
        count++;
        cout << "7" << endl;
    }
    if(a <= 11 && b >= 11) {
        count++;
        cout << "11" << endl;
    }
    int a1 = 0;
    int b1 = 0;
    int temp = a;
    while(temp != 0) {
        temp /= 10;
        a1++;
    }
    temp = b;
    while(temp != 0) {
        temp /= 10;
        b1++;
    }
    for(int i = max(3, a1); i <= b; i++) {
        creatHuiWen(i);
    }

    return 0;
}
```

###### Luogu1149

这种遍历其实效果很差，但是仍旧可以通过测试。

**对于n不太大的时候，可以用一种较差的枚举求出答案，在提交的时候用if else 即可**

```c++
#include <iostream>
#include <map>
#include <cstdio>
using namespace std;
int nums[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
int box[25];
int main() {
    
    // 1位加3位
    //memset()
    int n = 0;
    cin >> n;
    for(int i = 0; i <= 999; i++) {
        int count = 0;
        for(int j = 0; j <= 999; j++) {
            int temp = i + j;
            count = 4;
            int tempI = i;

            if(tempI == 0) {
                count += 6;
            }
            while(tempI != 0) {
                count += nums[tempI % 10];
                tempI /= 10;
            }
            
        
            int tempJ = j;
            if(tempJ == 0) {
                count += 6;
            }
            while(tempJ != 0) {
                count += nums[tempJ % 10];
                tempJ /= 10;
            }
            

            if(temp == 0) {
                count += 6;
            }
            while(temp != 0) {
                count += nums[temp % 10];
                temp /= 10;
            }
            
            if(count <= 24) box[count]++;
        
        }
    }

    
    cout << box[n] << endl;
    return 0;
}
```

###### Luogu3799

注意选4个之间的联系，利用联系减少枚举层数

```c++
#include <iostream>
using namespace std;
int n;
int maxLen;
int mod = 1e9 + 7;
typedef long long LL;
LL a[5050];     // a使用计数方式
LL count;
int main() {
    cin >> n;

    for(int i = 0; i < n; i++) {
        int temp = 0;
        cin >> temp;
        maxLen = max(maxLen, temp);
        a[temp]++;
    }

  
    // 枚举正三角（边长为a）长度，它的构成一定为两条边长为a，另外两条边凑成a
    for(int i = 1; i <= maxLen; i++) {
        LL a1 = a[i] * (a[i] - 1) / 2;
        LL a2 = 0;
        // 枚举凑出来的两条边
        for(int j = 1; j < i; j++) {
            int other = i - j;
            // 防止重复统计
            if(other < j) break;
            // 统计两遍
            if(other == j && a[other] >= 2) {
                a2 += a[other] * (a[other] - 1) / 2;
            }
            else if(other != j && a[other] >= 1 && a[j] >= 1) {
                a2 += a[other] * a[j];
            }
        }
        count += ((a1 * a2) % mod);
        count %= mod;
    }
    cout << count << endl;

    return 0;
}
```

###### Luogu1433

该题要使用状态压缩dp，还不会。

用枚举的话，为**排列枚举**，一般只能通过n<11情况，该题使用排列枚举，可以通过50%测试集，注意下面**next_permutation()**

```c++
#include <iostream>
#include <cmath>
#include <climits>
#include <algorithm>
#include <iomanip>
using namespace std;
int n;
double distance1;
pair<double, double> nums[20];
inline double get_distance(pair<double, double> one, pair<double, double> two) {
    return sqrt((one.first - two.first) * (one.first - two.first) + 
    (one.second - two.second) * (one.second - two.second));
}
// 排列枚举完成70%
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    distance1 = 999999999;
    cin >> n;
    
    for(int i = 1; i <= n; i++) {
        cin >> nums[i].first >> nums[i].second;
    }
    int cnt = 0;
    sort(nums + 1, nums + n + 1);
    do
    {
        double temp = 0;
        for(int i = 0; i < n; i++) {
            temp += get_distance(nums[i], nums[i + 1]);
        }
        distance1 = min(distance1, temp);
        cnt++;
    } while (next_permutation(nums + 1, nums + n + 1));

    cout << fixed << setprecision(2) << distance1 << endl;
    //cout << cnt << endl;
    return 0;
}
```

