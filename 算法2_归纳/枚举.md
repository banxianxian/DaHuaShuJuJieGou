<div align=center><font size=7>枚举</font></div>

[TOC]

##### 循环枚举

对于该类枚举问题，优化从两个方面考虑：

1. 对于枚举，进行剪枝
2. **更换不同的枚举方式**

对于2举个例子：

> 将1，2……，9共九个数分成三组，分别组成3个三位数，使得三个三位数满足A:B:C

我们可以枚举一个三位数，然后通过比例计算出另外两个三位数，最后判断条件（3个三位数不存在重复数字）是否成立。而不是一开始枚举三个三位数，在判断是否满足条件（A：B：C）。



##### 子集枚举

从一个集合里面选出子集，再判断子集是否满足条件的问题。

n个元素的子集有$2^n$个。

1. 用回溯法枚举
2. 使用2进制表示的数字，进行判断是否出现，可以使用stl中函数**_builtin_popcount()**统计一个数2进制表示1的个数

枚举子集复杂度为：O($2^n$)，**1s可以枚举20-30个元素的集合的子集**

##### 排列枚举

可以使用函数**next_permutation()**得到全排列。

全排列的时间复杂度是O(n!)，**1s很难枚举超过11个元素的全排列**。

##### stl函数使用：

###### _builtin_popcount()

###### next_permutation()

##### 题解

###### Luogu3654

当k=1时需要特判，行列两种方式是一样的。

```c++
// 循环枚举
#include <iostream>
using namespace std;
int R, C, K;
char nums[105][105];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> R >> C >> K;
    for(int i = 0; i < R; i++) {
        for(int j = 0; j < C; j++) {
            cin >> nums[i][j];
        }
    }
    int sum = 0;
    // 行排列
    for(int i = 0; i < R; i++) {
        int count = 0;
        for(int j = 0; j < C; j++) {
            if(nums[i][j] == '.') {
                count++;
                if(j != C - 1) continue;
            }
            
            if(count >= K) {
                sum += count - K + 1;
            }
            if(j + K >= C) {
                break;
            }
            count = 0;
            
        }
    }

    // 列排列
    for(int j = 0; j < C; j++) {
        int count = 0;
        for(int i = 0; i < R; i++) {
            if(nums[i][j] == '.') {
                count++;
                if(i != R - 1) continue; 
            }
            if(count >= K) {
                sum += count - K + 1;
            }
            if(i + K >= R) {
                break;
            }
            count = 0;
        }
    }

    // 1需要特判
    if(K == 1) cout << sum / 2 << endl;
    else cout << sum << endl;

    return 0;
}
```

###### Luogu1217

需要更换枚举方式，直接先构造回文数字（回文数字相对稀疏，3位的回文数字只有90，4位的回文数字90个，5位，6位900个）。

**回文数字比素数稀疏**

**偶数位的回文数字（除11外），一定是11的倍数，即一定不是素数**

```c++
#include <iostream>
using namespace std;
int a, b;
typedef long long LL;
LL count;

bool isPrime(int x) {
    if(x % 2 == 0) return false;
    for(int i = 3; i*i <= x; i += 2) {
        if(x % i == 0) return false; 
    }
    return true;
}
void creatHuiWen(int depth) {
    if(depth == 3) {
        for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                int palindrome = d1 * 100 + d2 * 10 + d1;
                if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                    cout << palindrome << endl;
                    count++;
                }
            }
        }
    }
   
    else if(depth == 5) {
        for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                for(int d3 = 0; d3 <= 9; d3++) {
                    int palindrome = d1 * 10000 + d2 * 1000 + d3 * 100 + d2 * 10 + d1;
                    if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                        cout << palindrome << endl;
                        count++;
                    }
                }
            }
        }
    }

    else if(depth == 7) {
        for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                for(int d3 = 0; d3 <= 9; d3++) {
                    for(int d4 = 0; d4 <= 9; d4++) {
                        int palindrome = d1 * 1000000 + d2 * 100000 + d3 * 10000 + 
                        d4 * 1000 + d3 * 100 + d2 * 10 + d1;
                        if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                            cout << palindrome << endl;
                            count++;
                        }
                    }
                }
            }
        }
    }
    else if(depth == 9) {
         for(int d1 = 1; d1 <= 9; d1 += 2) {
            for(int d2 = 0; d2 <= 9; d2++) {
                for(int d3 = 0; d3 <= 9; d3++) {
                    for(int d4 = 0; d4 <= 9; d4++) {
                        for(int d5 = 0; d5 <= 9; d5++) {
                            int palindrome = d1 * 100000000 + d2 * 10000000 + d3 * 1000000 + d4 * 100000 + 
                            d5 * 10000 + d4 * 1000 + d3 * 100 + d2 * 10 + d1;
                            if(a <= palindrome && palindrome <= b && isPrime(palindrome)) {
                                cout << palindrome << endl;
                                count++;
                            }
                        }
                    }
                }
            }
        }
    }
}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> a >> b;
    if(a <= 5 && b >= 5) {
        count++;
        cout << "5" << endl;
    }
    if(a <= 7 && b >= 7) {
        count++;
        cout << "7" << endl;
    }
    if(a <= 11 && b >= 11) {
        count++;
        cout << "11" << endl;
    }
    int a1 = 0;
    int b1 = 0;
    int temp = a;
    while(temp != 0) {
        temp /= 10;
        a1++;
    }
    temp = b;
    while(temp != 0) {
        temp /= 10;
        b1++;
    }
    for(int i = max(3, a1); i <= b; i++) {
        creatHuiWen(i);
    }

    return 0;
}
```

