<div align=center><font size=7>线段树</font></div>

[TOC]



**对线段树的复杂度仍旧不是很理解**

#### 理论

**定义：** 将**线性序列**组织成一个**树状序列**（二叉树），并在**对数复杂度**的下进行区间操作

**性质：**

- 线段树上面的任意一个节点，要么只有两个子节点或者没有子节点
- 维护一个长度为n的序列，需要建立的线段树的节点个数为(2n-1)
- 维护一个长度为n的序列，线段树的层数为$\log_2n$



**存储方式：**

采用树的性质存储方式**(left = 2 * i, right = 2 * i + 1)**

考虑线段树近似为一个完美二叉树，所以需要存储长度为i的序列，数组长度应该为(2n - 1) * 2 + 1 = **4n - 1**



通过该存储方式可以判断线段树的数据规模不能太大，不能无法开出足够大的数组进行存储



#### **线段树的可加性**

满足该性质的运算操作才能使用线段树来维护。

**为什么需要满足该性质？**

主要是考虑标签的使用，我们先假定有下面两个节点，它们均已经打上标签，并且标签未下传，假定现在的操作为求区间和。

此时开始查询grildchild1，2两个节点，需要先将标签下方，等价于grildchild1, grildchild2要加上tag1 + tag2

即grildchild1与grildchild2的标签应该为tag3 = tag1 + tag2

如果此时操作不为+，而是取余 tag1 = (对3取余)，tag2 = (对4取余)，那么tag3 是否 等于 (对7取余)呢？显然不对，即**操作%不满足可加性性质**

![](https://github.com/banxianxian/image/blob/main/%E6%B4%9B%E8%B0%B7/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BD%BF%E7%94%A8%E5%9B%BE.png?raw=true)



#### 基本操作

**建立线段树**

**复杂度：** 考虑build()函数单个节点的复杂度为O(1)，考虑递归O($\log_2n$)  n为序列个数

```c++
int a[maxn];		// 需要维护的序列
struct node {
    int L, R;	// 记录该节点维护的区间的左右端点
    int w;		// 记录区间和
    int tag;	// 延迟标记
} stree[4 * maxn]; // 线段树

void pushup(const int u) {
    // u为节点
    stree[u].w = stree[2 * u].w + stree[2 * u + 1].w;
}

void build(const int u, int L, int R) {
    if(L == R) {
        // 到达叶子节点
        stree[u].w = a[L];
        return;
    }
    
    int M = (L + R) >> 1;
    build(2 * u, L, M);
    build(2 * u + 1, M + 1, R);
    pushup(u);
}
```



**单点查询和修改：**

查询修改给出的**位置参数p**均为序列中的**下标**

**复杂度：**O($\log_2n$)  

```c++
// 单点查询
int query1(const int u, int  L, int R, int p) {
    if(L == R) {
        return stree[u].w;
    } else {
        int M = (L + R) >> 1;
        if(p <= M) {
            return query1(2 * u, L, M, p);
        }
        else {
            return query1(2 * u + 1, M + 1, R, p);
        }
    }
    
}

// 单点修改
void update1(const int u, int L, int R, int p, int change_value) {
    if(L == R) {
        stree[u].w = change_value;
        return;
    } else {
        int M = (L + R) >> 1;
        if(p <= M) {
            update1(2 * u, L, M, p, change_value);
        }
        else {
            update1(2 * u + 1, M + 1, R, p, change_value);
        }
        // 重点不能缺少
        pushup(u);
    }
}
```



**区间查询：**

**复杂度：** O($\log_2n$)  

```c++
// l 和 r为需要查找的区间
bool inRange(int L, int R, int l, int r) {
	return (l <= L) && (R <= r);
}

bool outRange(int L, int R, int l, int r) {
    return (R < l) || (L > r);
}

int query(const int u, int L, int R, int l, int r) {
	if(inRange(L, R, l, r)) {
        return stree[u].w;
    }
    else if(outRange) {
        return 0;
    }
    else {
        int M = (L + R) >> 1;
        pushdown(u, L, R);		// 下方标签
        return query(2 * u, L, M, l, r) + query(2 * u, M + 1, R, l, r);
    }
}
```



**区间修改：**

**思想：** 需要修改时，只在代表该区间的节点打上一个标签，之后在查询的时候，再顺便更新叶节点（类似并差集路径压缩的思想）

**复杂度：**O($\log_2n$)  

```c++
void maketag(const int u, int len, int change_value) {
    stree[u].tag += change_value;
    stree[u].w += len * change_value;
}
void push_down(const int u, int L, int R) {
    int M = (L + R) >> 1;
    maketag(2 * u, M - L + 1, stree[u].tag);
    maketag(2 * u + 1, R - M, stree[u].tag);
    stree[u].tag = 0;
}
void update(int u, int L, int R, int l, int r, int change_value) {
    if(inRange(L, R, l, r)) {
        maketag(u, R - L + 1, change_value);
    }
    else if(!outRange(L, R, l, r)) {
        int M = (L + R) / 2;
        push_down(u, L, R);		//重点
        update(2 * u, L, M, l, r, change_value);
        update(2 * u + 1, M + 1, R, l, r, change_value);
        pushup(u);
    }
}
```



#### stl知识

函数：**accumulate()**

头文件：#include < numeric >

**注意点：** 

accumualte(nums.begin(), nums.end(), **int(0)**)

accumulate(nums.begin, nums.end(), **long long(0)**)

第三个参数是什么类型，那么在求和过程中也是这个变量用来存储求和结果，而不是与nums的数据类型相同



#### 题解

###### Luogu3372

通过这道题可以知道，线段树的速度还是要高于朴素的算法的

**线段树：**

```c++
// 线段树
#include <bits/stdc++.h>
#include <ctime>
using namespace std;
int n, m;
int a[100005];
struct node {
    int L, R;
    long long w;
    int tag;
} stree[400050];

bool inRange(int L, int R, int l, int r) {
    return (l <= L) && (r >= R);
}

bool outRange(int L, int R, int l, int r) {
    return (R < l) || (r < L);
}


void pushup(const int u) {
    stree[u].w = stree[2 * u].w + stree[2 * u + 1].w;
}

void maketag(const int u, int len, int change_value) {
    stree[u].tag += change_value;
    stree[u].w += len * change_value;
}

void push_down(const int u, int L, int R) {
    int M = (L + R) >> 1;
    maketag(2 * u, M - L + 1, stree[u].tag);
    maketag(2 * u + 1, R - M, stree[u].tag);
    stree[u].tag = 0;
}

void build(const int u, int L, int R) {
    if(L == R) {
        stree[u].w = a[L];
        return;
    }
    int M = (L + R) >> 1;
    build(2 * u, L, M);
    build(2 * u + 1, M + 1, R);
    pushup(u);
}

long long query(const int u, int L, int R, int l, int r) {
    if(inRange(L, R, l, r)) {
        return stree[u].w;
    }
    else if(outRange(L, R, l, r)) {
        return 0;
    }
    else {
        int M = (L + R) >> 1;
        push_down(u, L, R);
        return query(2 * u, L, M, l, r) + query(2 * u + 1, M + 1, R, l, r);
    }

}

void update(const int u, int L, int R, int l, int r, int change_value) {
    if(inRange(L, R, l, r)) {
        maketag(u, R - L + 1, change_value);
    }
    else if(!outRange(L, R, l, r)) {
        int M = (L + R) >> 1;
        push_down(u, L, R);
        update(2 * u, L, M, l, r, change_value);
        update(2 * u + 1, M + 1, R, l, r, change_value);
        pushup(u);
    }
}

int main() {
  
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    build(1, 1, n);

    for(int i = 0; i < m; i++) {
        int op = 0, x = 0, y = 0, k = 0;
        cin >> op;
        if(op == 1) {
            cin >> x >> y >> k;
            update(1, 1, n, x, y, k);
        }
        else {
            cin >> x >> y;
            cout << query(1, 1, n, x, y) << endl;
        }
    }
    return 0;
}
```



**暴力：**



```c++
#include <iostream>
#include <algorithm>
#include <fstream>
#include <numeric>
#include <ctime>
using namespace std;
// D:\newDemoc++\LuoGU\3372_data.txt
int n, m;
long long nums[100005];
int main() {
    clock_t start_time = clock();

    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    ifstream in;
    in.open(R"(D:\newDemoc++\LuoGU\3372_data.txt)", ios::in);
    if(in.is_open() == false) {
        cout << "error" << endl;
    }

    in >> n >> m;
    for(int i = 1; i <= n; i++) {
        in >> nums[i];
    }

    for(int i = 0; i < m; i++) {
        int op = 0;
        in >> op;
        if(op == 1) {
            int x, y, k;
            in >> x >> y >> k;
            for(int j = x; j <= y; j++) {
                nums[j] += k;
            }
        }
        else {
            long long x, y;
            in >> x >> y;
            long long sum = 0;
            // 计数临时存储以开始值的变量类型存储，不是传入的数组
            sum = accumulate(nums + x, nums + y + 1, (long long)0);
            cout << sum << endl;
        }
    }

    in.close();

    clock_t end_time = clock();
    double duration = (double)(end_time - start_time) / CLOCKS_PER_SEC;
    cout << "程序运行时间：" << duration << "s" << endl;
    return 0;
}
```



###### Luogu3870

对于线段树的题目，主要是需要修改标记tag的代码

```c++
#include <iostream>
using namespace std;

int n, m;
struct node {
    int w;      // 记录1的数量
    int L, R;
    int tag;    // 标记是否需要反转
} stree[400050];

void pushup(const int u) {
    stree[u].w = stree[2 * u].w + stree[2 * u + 1].w;
}

void maketag(const int u, int L, int R, int change_value) {
    
    if(change_value == 0) return;
    stree[u].tag ^= change_value;
    stree[u].w = R - L + 1 - stree[u].w;
    
    
}

void push_down(const int u, int L, int R) {
    int M = (L + R) >> 1;
    maketag(2 * u, L, M, stree[u].tag);
    maketag(2 * u + 1, M + 1, R, stree[u].tag);
    stree[u].tag = 0;
}

bool inRange(int L, int R, int l, int r) {
    return (L >= l) && (R <= r);
}

bool outRange(int L, int R, int l, int r) {
    return (R < l) || (L > r);
}

void build(const int u, int L, int R) {
    if(L == R) {
        stree[u].w = 0;
        return;
    }
    else {
        int M = (L + R) >> 1;
        build(2 * u, L, M);
        build(2 * u + 1, M + 1, R);
        pushup(u);
    }

}


void update(const int u, int L, int R, int l, int r) {
    if(inRange(L, R, l, r)) {
        maketag(u, L, R, 1);
        return;
    }
    else if(!outRange(L, R, l, r)) {
        int M = (L + R) >> 1;
        push_down(u, L, R);
        update(2 * u, L, M, l, r);
        update(2 * u + 1, M + 1, R, l, r);
        pushup(u);
    }

}

long long query(const int u, int L, int R, int l, int r) {
    if(inRange(L, R, l, r)) {
        return stree[u].w;
    }
    else if(outRange(L, R, l, r)) {
        return 0;
    }
    else {
        int M = (L + R) >> 1;
        push_down(u, L, R);
        return query(2 * u, L, M, l, r) + query(2 * u + 1, M + 1, R, l, r);

    }
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n >> m;
    // 其实这个初始化没什么意义
    build(1, 1, n);
    for(int i = 0; i < m; i++) {
        int op = 0, a = 0, b = 0;
        cin >> op >> a >> b;
        if(op == 0) {
            update(1, 1, n, a, b);

        }
        else {
            cout << query(1, 1, n, a, b) << endl;
        }
    }


    return 0;
}
```



###### Luogu1438

**可以通过本题，理解线段树的可加性：** 观察`maketag()函数中的tagK 与 tagD`的加法操作，为什么会存在这样的操作？第一次打标签在子节点上（假定标签为tagk1 = 1, tagd1 = 1），且该标签还没下穿，然后第二次标签打在其父节点上面（假定标签为tagk2 = 1, tagd2 = 2），此时对与子节点对应的区间相当于加了两个数组，即加了标签`tagk3=tagk1 + tagk2，tagd3 = tagd1 + tagd2`

```c++
#include <iostream>
#include <fstream>
using namespace std;
typedef long long ll;
const int maxn =100000;
ll a[maxn];		// 需要维护的序列
struct node {
    ll w;		// 记录区间和
    ll tagK;	// 延迟标记
    ll tagD;
} stree[4 * maxn]; // 线段树

ll sum1(ll K, ll D, ll len) {
    return 1ll *(K + (len - 1) * D + K) * len / 2;
}
// l 和 r为需要查找的区间
bool inRange(ll L, ll R, ll l, ll r) {
	return (l <= L) && (R <= r);
}

bool outRange(ll L, ll R, ll l, ll r) {
    return (R < l) || (L > r);
}

void pushup(const int u) {
    // u为节点
    stree[u].w = stree[2 * u].w + stree[2 * u + 1].w;
}

void build(const int u, ll L, ll R) {
    if(L == R) {
        // 到达叶子节点
        stree[u].w = a[L];
        return;
    }
    
    ll M = (L + R) >> 1;
    build(2 * u, L, M);
    build(2 * u + 1, M + 1, R);
    pushup(u);
}

void maketag(const int u, int len, ll tagK, ll tagD) {
    // 可加性
    if(tagK == 0 && tagD == 0) return;
    stree[u].tagK += tagK;
    stree[u].tagD += tagD;
    stree[u].w += sum1(tagK, tagD, len);
}

void push_down(const int u, int L, int R) {
    ll M = (L + R) >> 1;
    maketag(2 * u, M - L + 1, stree[u].tagK, stree[u].tagD);
    maketag(2 * u + 1, R - M, stree[u].tagK + (M - L + 1) * stree[u].tagD, stree[u].tagD);
    stree[u].tagK = 0;
    stree[u].tagD = 0;
}

void update(int u, ll L, ll R, ll l, ll r, ll tagK, ll tagD) {
    if(inRange(L, R, l, r)) {
        tagK = tagK + (L - l) * tagD;
        maketag(u, R - L + 1, tagK, tagD);
    }
    else if(!outRange(L, R, l, r)) {
        ll M = (L + R) / 2;
        push_down(u, L, R);		//重点
        update(2 * u, L, M, l, r, tagK, tagD);
        update(2 * u + 1, M + 1, R, l, r, tagK, tagD);
        pushup(u);
    }
}

// 单点查询
long long query1(const int u, ll  L, ll R, int p) {
    if(L == R) {
        return stree[u].w;
    } else {
        ll M = (L + R) >> 1;
        push_down(u, L, R);
        if(p <= M) {
            return query1(2 * u, L, M, p);
        }
        else {
            return query1(2 * u + 1, M + 1, R, p);
        }
    }
    
}

int n, m;

int main() {
    ios::sync_with_stdio(false);
    //cin.tie(0), cout.tie(0);
    
    

    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    
    build(1, 1, n);

    for(int i = 0; i < m; i++) {
        int opt = 0;
        cin >> opt;
        
        if(opt == 1) {
            int  l, r, K, D;
            cin >> l >> r >> K >> D;
            update(1, 1, n, l, r, K, D);
        }
        else {
            int p;
            cin >> p;
            cout << query1(1, 1, n, p) << endl;
        }
    }
    
    
    return 0;
}
```

