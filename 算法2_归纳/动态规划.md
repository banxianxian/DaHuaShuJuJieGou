<div align=center><font size=7>动态规划</font></div>

------

[TOC]



### 理论部分

动态规划（Dynamic Programming，DP）

**定义：** 通过将原问题分解成若干相关的子问题（所有**这些问题在一定意义上答案固定**），再利用子问题计算未知问题答案



**问题分类：**

1. 最优化问题
2. 组合计数问题



**一些术语：**

<u>状态</u> （最困难的一步）： “问题所在的局面”，一般描述为：（用**变量**表示）所在局面的（最优）答案

如果无法有效得到状态，但是会使用**暴力搜索**或者**记忆化搜索**，可以从搜索中抽象得到需要的状态



<u>转移</u> ： 描述状态之间的关系，通过**状态转移方程**描述

分类：

- 发送型转移：从当前状态，计算对后继的贡献
- 接受型转移：从当前状态，计算对前驱的贡献



<u>无后效性</u>： 利用DAG（有向无环图）来理解无后效性，每个节点对于一个状态，需要得到该节点答案，必须先将其前驱全部访问过



### 解题方法

参考算法总结1里面的动态规划内容

[动态规划](https://github.com/banxianxian/DaHuaShuJuJieGou/tree/simple/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%931)

#### 解题步骤

![](https://github.com/banxianxian/image/blob/main/%E6%B4%9B%E8%B0%B7/Snipaste_2024-03-12_16-14-48.png?raw=true)



![](https://github.com/banxianxian/image/blob/main/%E6%B4%9B%E8%B0%B7/Snipaste_2024-03-12_16-15-20.png?raw=true)

#### DAG与动态规划问题的讨论

许多问题可以转化为求解DAG上面的**最长路**问题，可以使用dp解决，但是推荐使用**记忆化搜索**来完成

**解法：**

- 拓扑排序
- 按照**拓扑序**dp
- 记忆化搜索

dp是必须按照拓扑序进行，有些时候拓扑序可以直接得到，有些时候需要其它方法（拓扑排序）来找到拓扑序

**参考例题：**

Luogu1434 滑雪



### 题解

###### Luogu1216

**记忆化搜索：**

```c++
#include <iostream>
#include <cstring>
using namespace std;
int r;
int map[1005][1005];
int memory[1005][1005];
int dfs(int x, int y) {
    if(x == r - 1) {
        return map[x][y];
    }
    if(memory[x][y] != -1) return memory[x][y];

    int t1 = dfs(x + 1, y);
    int t2 = dfs(x + 1, y + 1);
    
    return memory[x][y] =  max(t1, t2) + map[x][y];
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    memset(memory, -1, sizeof(memory));
    // 读入数据
    cin >> r;
    for(int i = 0; i < r; i++) {
        for(int j = 0; j <= i; j++) {
            cin >> map[i][j];
        }
    }

    
    cout << dfs(0, 0) << endl;
    return 0;
}
```



**动态规划：**

```c++
// 使用动态规划求解
// 状态定义：dp[i][j] 代表 从位置(i,j)到达底部的最大权值
#include <iostream>
using namespace std;
int dp[1005][1005];
int r;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    
    cin >> r;
    for(int i = 0; i < r; i++) {
        for(int j = 0; j <= i; j++) {
            cin >> dp[i][j];
        }
    }

    // 动态规划部分
    for(int i = r - 2; i >= 0; i--) {
        for(int j = 0; j <= r; j++) {
            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + dp[i][j];
        }
    }

    cout << dp[0][0] << endl;
    return 0;
}
```



###### Luogu1048

01背包问题

```c++
#include <iostream>
// 状态定义：dp[i,j]表示当考虑前i株草药，背包容量（采药时间）为j时，能够得到的最大价值
#include <vector>
using namespace std;
int T, M;
vector<pair<int, int>> drugs(105, {0,0});
int dp[105][1005];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> T >> M;
    for(int i = 1; i <= M; i++) {
        cin >> drugs[i].first >> drugs[i].second;
    }

    // 初始化
    // dp[0][i] = 0, dp[i][0] = 0

    for(int i = 1; i <= M; i++) {
        for(int j = 1; j <= T; j++) {
            if(j >= drugs[i].first) 
                dp[i][j] = max(dp[i - 1][j - drugs[i].first] + drugs[i].second, dp[i - 1][j]);
            else dp[i][j] = dp[i - 1][j];
        }
    }

    cout << dp[M][T] << endl;

    return 0;
}
```



###### Luogu2196

```c++
#include <bits/stdc++.h>
using namespace std;
int N;
int nums[25];
vector<int> p[25];
vector<int> path[25];
int dp[25];
int imax;
int smax;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N;
    for(int i = 1; i <= N; i++) cin >> nums[i];

    for(int i = 1; i <= N - 1; i++) {
        for(int j = i + 1; j <= N; j++) {
            int temp = 0;
            cin >> temp;
            if(temp == 1) {
                p[i].push_back(j);
            }
        }
    }

    // 开始dp
    for(int i = N; i >= 0; i--) {
        if(p[i].size() == 0) {
            dp[i] = nums[i];
            path[i].push_back(i);
            if(dp[i] > smax) {
                smax = dp[i];
                imax = i;
            }
        }
        else {
            int index_max = 0;
            int max_nums = 0;
            
            for(int j = 0; j < p[i].size(); j++) {
                int t = p[i][j];
                if(dp[t] > max_nums) {
                    max_nums = dp[t];
                    index_max = t;
                }
            }

            dp[i] = max_nums + nums[i];
            path[i] = path[index_max]; 
            path[i].push_back(i);

            if(dp[i] > smax) {
                smax = dp[i];
                imax = i;
            }
        }
    
    }

    for(int i = path[imax].size() - 1; i >= 0; i--) {
        cout << path[imax][i] << " ";
    }
    cout << endl;
    cout << smax << endl;
    return 0;
}
```



###### Luogu1434

**记忆化搜索：**

没有对是否访问过进行标记，因为第20行的if判断，避免了出现死循环的情况

```c++
#include <bits/stdc++.h>
using namespace std;
int map1[105][105];
int row, col;
int move1[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
int mem[105][105];
int ans;
int dfs(int x, int y) {
    if(x < 0 || x >= row || y < 0 || y >= col) {
        return 0;
    }
    else if(mem[x][y] != -1) return mem[x][y];

    

    int max1 = 0;
    for(int i = 0; i < 4; i++) {
        int newx = x + move1[i][0];
        int newy = y + move1[i][1];
        // 由于判断确定了方向，因而不会出现死循环
        if(map1[newx][newy] < map1[x][y]) max1 = max(dfs(newx, newy), max1);
    }

    ans = max(ans, max1 + 1);
    return mem[x][y] = max1 + 1;

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    memset(mem, -1, sizeof(mem));
    cin >> row >> col;
    for(int i = 0; i < row; i++) {
        for(int j = 0; j < col; j++) {
            cin >> map1[i][j];
        }
    }

    for(int i = 0; i < row; i++) {
        for(int j = 0; j < col; j++) {
            dfs(i, j);
        }
    }

    cout << ans << endl;
    return 0;
}
```



###### Luogu1115

线性动态规划问题

```c++
#include <iostream>
using namespace std;
typedef long long ll;
ll nums[200005];
int n;
ll ans = -1e9;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    for(int i = 0; i < n; i++) cin >> nums[i];

    for(int i = 1; i < n; i++) {
        nums[i] = max(nums[i - 1] + nums[i], nums[i]);
        ans = max(ans, nums[i]);
    }

    cout << ans << endl;


    return 0;
}
```

