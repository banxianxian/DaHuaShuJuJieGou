<div align=center><font size=7>集合</font></div>



[TOC]



##### 并查集

###### 1. 普通并查集

**定义**：处理不相交可合并的集合关系的数据结构

**基本操作（模板）：**

1. 查询
2. 合并

```c++
int father[MAXN];
// 初始化
for(int i = 0; i < MAXN; i++) {
    father[i] = i;
}
// 查询
int find(int x) {
    if(x == fa[x]) return x;
    return fa[x] = find(fa[x]);		// 一种优化方式（路径压缩优化）
}

// 合并
void merge(int c1, int c2) {
    int f1 = find(c1);
    int f2 = find(c2);
    if(f1 != f2) fa[f1] = f2; 
}

```

**优化方式：**

1. 路径压缩优化（上面标注的行）

复杂度：O(logn)

2. 按秩合并优化（还未实现）



###### 2. 种类并查集

一个普通的并查集只能表示一种关系

**用途:**  当一个问题中拥有**多个关系**时使用（满足并查集的使用条件）

**实现方法：**通过将`father[]`扩大为$n\times m$ （n为元素个数，m为关系个数）

典型例题: [食物链](https://www.luogu.com.cn/blog/Sooke/solution-p2024)

 

###### 3. 按权并查集



##### hash表

哈希表相对熟悉，不详细赘述。

为了防止哈希冲突，可以构建链表。

**字符串映射成hash：** 可以使用公式`hash=(hash * base + s[i]) % mod`，base为常数一般>=128

mod通常取较大质数如**10007，999983**



##### stl知识

set容器：本质是红黑树（一种AVL树）

map容器：本质也是红黑树

unordered_set容器：基于**哈希表**的无序集合，插入，删除，查找的复杂度大多数情况均为O(1)（无hash冲突）

unordered_map容器：一种哈希表

##### 题解

###### Luogu1536

本题考查并查集，在检查有多少个不相交的集合的时候可以通过`father[x]==x`来统计

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int maxN = 1005;
int father[maxN];
// 查找函数
int find(int x) {
    if(x == father[x]) {
        return x;
    }
    return father[x] = find(father[x]);
}

void join(int c1, int c2) {
    int f1 = find(c1);
    int f2 = find(c2);
    if(f1 != f2) {
        father[f1] = f2;
    }

}

int main() {

    while(1) {
        int temp1 = 0, temp2 = 0;
        cin >> temp1;
        if(temp1 == 0) break;
        else cin >> temp2;

        // 初始化
        for(int i = 1; i <= temp1; i++) {
            father[i] = i;
        }

        // 构建并查集
        for(int i = 1; i <= temp2; i++) {
            int v1 = 0, v2 = 0;
            cin >> v1 >> v2;
            join(v1, v2);
        }

        // 统计结果
        int cnt = 0;
        for(int i = 1; i <= temp1; i++) {
            if(father[i] == i) cnt++;
        }

        cout << cnt - 1 << endl;
        memset(father, 0, sizeof(father));

    }


    return 0;
}
```



###### Luogu1918

hash表(map)

```c++
#include <iostream>
#include <map>
using namespace std;
int main() {
    int n = 0;
    int Q = 0;
    map<int, int> box;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        int temp = 0;
        cin >> temp;
        box[temp] = i;
    }

    cin >> Q;
    for(int i = 0; i < Q; i++) {
        int temp = 0;
        cin >> temp;
        cout << box[temp] << endl;
    }

    return 0;
}
```



###### Luogu1621

**思路：**不是将数分解判断是否有相同的质因子，而是从相同的质因子出发，通过对质因子倍增得到具有相同公质因子的两个数。

**注意：** 下面代码需要关闭O2优化才能通过，不知道原因（可能是<u>没开时数组越界会直接访问程序内对应位置的空间当作无事发生，但 O2 会检测数组越界。</u>），需要注意`24, 37行j可能会越界的情况`，在埃氏筛中，同样可能发生越界。

```c++
// 筛选质数，在求该质数倍数在[a,b]之间的元素
#include <bits/stdc++.h>
using namespace std;
int a, b, p;
int vis[100005];
int father[100005];
int find(int x) {
    if(father[x] == x) return x;
    return father[x] = find(father[x]);
}
int main() {
    cin >> a >> b >> p;

    // 初始化并查集
    for(int i = a; i <= b; i++) {
        father[i] = i;
    }

    int ans = 0;
    // 埃氏筛(有一些区别)
    for(int i = 2; i <= b; i++) {
        // 如果i是质数的情况，即i可能为公共质因子
        if(!vis[i] && i >= p) {
            for(int j = i * 2; j <= b && j >= 0; j += i) {
                // j - i与j为拥有公共质因子i的范围在[a, b]之间的元素
                // find(j - i) 与 find(i)说明其不在一个集合中
                vis[j] = 1;
                if(j - i >= a && j <= b && find(j - i) != find(j)) {
                    ans++;
                    father[find(j - i)] = father[find(j)];
                }
            }
        }
        else {
            // 如果i不是质数
            // i * i可能导致j越界
            for(int j = i * i; j <= b && j >= 0; j += i) {
                vis[j] = 1;
            } 
        }
    }

    cout << b - a + 1 - ans << endl;
    

    return 0;
}
```

将24，和37行代码进行修改，也能通过O2，

```c++
// 筛选质数，在求该质数倍数在[a,b]之间的元素
#include <bits/stdc++.h>
using namespace std;
int a, b, p;
int vis[100005];
int father[100005];
int find(int x) {
    if(father[x] == x) return x;
    return father[x] = find(father[x]);
}
int main() {
    cin >> a >> b >> p;

    // 初始化并查集
    for(int i = a; i <= b; i++) {
        father[i] = i;
    }

    int ans = 0;
    // 埃氏筛(有一些区别)
    for(int i = 2; i <= b; i++) {
        // 如果i是质数的情况，即i可能为公共质因子
        if(!vis[i] && i >= p) {
            for(long long j = (long long)i * 2; j <= b && (int)j >= 0; j += i) {
                // j - i与j为拥有公共质因子i的范围在[a, b]之间的元素
                // find(j - i) 与 find(i)说明其不在一个集合中
                vis[j] = 1;
                if(j - i >= a && j <= b && find(j - i) != find(j)) {
                    ans++;
                    father[find(j - i)] = father[find(j)];
                }
            }
        }
        else {
            // 如果i不是质数
            for(long long j = (long long)i * i; j <= b && (int)j >= 0; j += i) {
                vis[j] = 1;
            } 
        }
    }

    cout << b - a + 1 - ans << endl;
    

    return 0;
}
```



###### Luogu1525

本题有两种解法

**解法1：** 

思路：

- 二分查找：用暴力思路解释，如果上传的矛盾值为mid，显然>mid一定可以成立，只需要考虑小于mid的部分

- 二部图：使用邻接表的方式构造，如果矛盾值>mid，那么该边才能加入图中，通过验证图是否为二部图来判断该值是否成立

- 二部图判断方法：

  使用定理：**不存在奇数圈的图是二部图**

​        编码方法：通过**染色法**实现

```c++
// 使用二部图完成，图的存储结构使用邻接表（节省空间）
// 同时使用二分查找
#include <bits/stdc++.h>
using namespace std;
struct Edge {
    int weight;
    int from;
    int to;
    int pre;
    Edge():weight(0), from(0), to(0), pre(0) {}
} edge[300005];
int head[200005];
int N, M;
int cnt;
void addEdge(int x, int y, int weight) {
    cnt++;          // 代表这是第几条边
    edge[cnt].from = x;
    edge[cnt].to = y;
    edge[cnt].weight = weight;
    // 使用头插法，插入新节点
    edge[cnt].pre = head[x];
    head[x] = cnt;
}


bool work(int mid) {
    // 当权值超过mid时，才算边，判断图是否为二部图（是否不含有奇圈），通过染色来验证
    // 1-N为点，color代表该点对应颜色（奇数圈无法使用两种颜色进行点着色，偶数圈可以）
    int color[100005] = {0};
    // bfs进行邻接表的访问
    queue<int> Q;
    for(int j = 1; j <= N; j++) {
        if(!color[j]) {
            Q.push(j);
            color[j] = 1;       // 为什么可以直接赋值为1号，可以看成访问若干连通分支（最外层for），这是连通分支
                                // 第一个点，因而可以随意赋值一个颜色
            while(!Q.empty()) {
                int t = Q.front();
                Q.pop();
                // 给t的邻接点着色，并且入队列
                // 当邻接表的pre为0时，代表访问了所有节点
                for(int i = head[t]; i; i = edge[i].pre) {
                    // i为边的编号
                    if(edge[i].weight > mid) {
                        if(color[t] == 1 && color[edge[i].to] == 0) {
                            color[edge[i].to] = 2; Q.push(edge[i].to);
                        }
                        else if(color[t] == 2 && color[edge[i].to] == 0) {
                            color[edge[i].to] = 1; Q.push(edge[i].to);
                        }
                        else if(color[edge[i].to] == color[t]) return false;
                    }
                }
            }
        }
    }
    return true;
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int right = 0, left = 0;

    cin >> N >> M;
    for(int i = 0; i < M; i++) {
        int temp1 = 0, temp2 = 0, weight = 0;
        cin >> temp1 >> temp2 >> weight;
        right = max(right, weight);
        // 构造邻接表
        addEdge(temp1, temp2, weight);
        addEdge(temp2, temp1, weight);
    }

    int mid = 0, ans = 0;;
    while(left <= right) {
        mid = left + (right - left) / 2;
        if(work(mid)) {
            ans = mid;
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }

    cout << ans << endl;

    return 0;
}
```

**方法2：**

种类并查集实现



```c++
#include <iostream>
#include <algorithm>
using namespace std;
int N, M;
struct Edge {
    int a;
    int b;
    int weight;
} edge[100005];

int father[40005];
bool cmp(const struct Edge& a, const struct Edge& b) {
    if(a.weight > b.weight) return true;
    return false;
}
int find(int x) {
    if(x == father[x]) return x;
    return father[x] = find(father[x]);
}

void merge(int c1, int c2) {
    int f1 = find(c1);
    int f2 = find(c2);
    father[f1] = f2;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N >> M;
    // 并查集初始化
    for(int i = 1; i <= 2 * N; i++) {
        father[i] = i;
    }

    // 
    for(int i = 0; i < M; i++) {
        cin >> edge[i].a >> edge[i].b >> edge[i].weight;
    }

    sort(edge, edge + M, cmp);
    int ans = 0;
    // 分为两个关系，朋友和敌人
    for(int j = 0; j < M; j++) {
        int a = edge[j].a;
        int b = edge[j].b;
        if(find(a) == find(b)) {
            ans = edge[j].weight;
            break;
        }
        merge(a, b + N);        // 把a与b的敌人合并
        merge(b, a + N);        // 把b与a的敌人合并
    }

    cout << ans << endl;

    return 0;
}
```



###### Luogu2024

本题考查种类并查集

**father含义: **

| 1    | 2    | 3    | 4     | 5     | 6     | 7      | 8      | 9      |
| ---- | ---- | ---- | ----- | ----- | ----- | ------ | ------ | ------ |
| x    | y    | z    | x + N | y + N | z + N | x + 2N | y + 2N | z + 2N |

1-3:	代表同类关系

4-6:    代表捕食关系
7-9： 代表天敌关系

**重点：** 在判断是否为假话时的条件，并未设计第三个部分天敌（x + 2 * N 与 y + 2 * N）

所以其实，我们只需要将关系收缩到是否为同类，以及是否为捕食关系即可（即一个动物x与其它动物y：x与y是同类，x捕食y，y捕食x）

而find(x) == find(y + N)代表y捕食x，

find(x + N) = find(Y)，代表x捕食y，

find(x) = find(y)代表x与y是同类。

但这样并不行，因为无法成功构造关系，当捕食为x 吃 y，无法正确得到z吃x的隐含关系

所以并不能在合并时取消合并天敌相关关系，该关系作为中介，联系上捕食与被捕食

```c++
#include <iostream>
using namespace std;
int N, K;
int error;
// 使用种类并查集
int father[150005];
// 构造普通并查集
int find(int x) {
    if(x == father[x]) return x;
    return father[x] = find(father[x]);
}

void merge(int c1, int c2) {
    int f1 = find(c1);
    int f2 = find(c2);
    father[f1] = f2;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N >> K;
    // 初始化并查集
    for(int i = 1; i <= 3 * N; i++) {
        father[i] = i;
    }

    int x = 0, y = 0;
    int status = 0;
    for(int i = 0; i < K; i++) {
        cin >> status >> x >> y;
        // 第二种犯错
        if(x > N || y > N) {
            error++;
            continue;
        }
        // 第三种犯错情况
        else if(status == 2 && x == y) {
            error++;
            continue;
        }

        // 第一种犯错情况（这句话不发生冲突）
        // 如果输入1 x y 发生冲突
        if(status == 1) {
            // 不应该存在x吃y, 或者y吃x
            if(find(x) == find(y + N) || find(y) == find(x + N)) {
                error++;
                continue;
            }
        }
        else if(status == 2) {
            if(!(find(x) != find(y) && find(y + N) != find(x))) {
                error++;
                continue;
            }
        }

        // 如果这句话为真话，需要维护关系
        if(status == 1) {
            merge(x, y);
            merge(x + N, y + N);
            merge(x + 2 * N, y + 2 * N);
        }
        else if(status == 2) {
            merge(x + N, y);
            merge(y + N, x + 2 * N);
            merge(x, y + 2 * N);
        }

    }
    cout << error << endl;
    return 0;
}
```



###### Luogu8654

本题考查并查集

```c++
#include <bits/stdc++.h>
using namespace std;
int fa[1000009];

int find(int x) {
    if(fa[x] == x) return x;
    fa[x] = find(fa[x]);
    return fa[x];
}

void merge(int x1, int x2) {
    int f1 = find(x1);
    int f2 = find(x2);
    fa[f1] = f2;
}

int main() {

    


    int m = 0, n = 0;
    int k = 0;
    cin >> m >> n;

    for(int i = 1; i <= m * n; i++) {
        fa[i] = i;
    }


    cin >> k;
    for(int i = 1; i <= k; i++) {
        int x = 0, y = 0;
        cin >> x >> y;
        merge(x, y);
    }

    int cnt = 0;
    for(int i = 1; i <= m * n; i++) {
        if(i == find(i)) cnt++;
    }

    cout << cnt << endl;

    return 0;
}
```



###### Luogu1892

使用**种类并查集**（不太理解为什么对于敌人关系，需要合并两次31，32两行）

对于最后统计结果不能`if(fa[i] == i) cnt++`

因为同一个类的根节点可能超出n，而在n <    <= 2 *n 的范围

```c++
#include <iostream>
#include <unordered_set>
using namespace std;
int fa[1000009];
int find(int x) {
    if(x == fa[x]) {
        return x;
    }

    return fa[x] = find(fa[x]);
}
void merge(int x1, int x2) {
    int f1 = find(x1);
    int f2 = find(x2);
    fa[f1] = f2;
}
int main() {
    int n = 0, m = 0;
    cin >> n >> m;
    for(int i = 1; i <= 2 * n; i++) fa[i] = i;

    for(int i = 0; i < m; i++) {
        char ch = 0;
        int x1 = 0, x2 = 0;
        cin >> ch >> x1 >> x2;

        if(ch == 'F') {
            merge(x1, x2);
        }
        else {
            merge(x1, x2 + n);
            merge(x1 + n, x2);
        }
    }

    // 统计结果
    unordered_set<int> box;
    int cnt = 0;
    for(int i = 1; i <= n; i++) {
        box.insert(find(i));
    }

    cout << box.size() << endl;
    //for(int i = 1; i <= n; i++) cout << fa[i] << " ";

    return 0;
}
```



###### Luogu4305

集合最基本使用。

需要注意下面几个点：

1. int类型数组只能开到$10^7$左右
2. **第6，7行代码对于读入很多的情况，有极大的优化，必须加上**

```c++
#include <iostream>
#include <unordered_set>
using namespace std;
int T, n;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> T;
    for(int i = 0; i < T; i++) {
        cin >> n;
        unordered_set<int> box;
        for(int i = 0; i < n; i++) {
            int t = 0;
            cin >> t;
            if(box.find(t) == box.end()) {
                cout << t << " ";
                box.emplace(t);
            }

        }
        cout << endl;
    }

    return 0;
}
```



###### Luogu3879

简单使用unordered_map加上一个数组就可以解决

```c++
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;
int N, M, L;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> N;

    unordered_map<string, int> box;
    vector<vector<int>> box1(5e6, vector<int>(0));
    int kind = 1;
    for(int i = 1; i <= N; i++) {
        // 处理文章
        cin >> L;
        for(int j = 1; j <= L; j++) {
            string temp;
            cin >> temp;
            if(box[temp] == 0) {
                box[temp] = kind++;
                box1[box[temp]].push_back(i);
            }
            else {
                if(box1[box[temp]][box1[box[temp]].size() - 1] != i) box1[box[temp]].push_back(i);
            }
        }

    }

    cin >> M;
    for(int i = 0; i < M; i++) {
        string temp;
        cin >> temp;
        int index = box[temp];
        for(int i = 0; i < box1[index].size(); i++) {
            if(i != box1[index].size() - 1) {
                cout << box1[index][i] << " ";
            }
            else {
                cout << box1[index][i];
            }
        }
        cout << endl;
    }

    return 0;
}
```



###### Luogu2814

考查并查集和hash表

注意：

1. 注意merge函数合并时，谁在后面，谁为父节点

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;
int kind = 1;	// 不能为0
int fa[50009];
int find(int x) {
    if(x == fa[x]) return x;
    return fa[x] = find(fa[x]);
}

void merge(int x1, int x2) {
    int f1 = find(x1);
    int f2 = find(x2);
    fa[f1] = f2;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    for(int i = 0; i < 50009; i++) fa[i] = i;
    unordered_map<string, int> box;
    string t[500009];

    // 读入数据
    string temp;
    int cnt = 0;
    cin >> temp;
    while(temp != "$") {
        t[cnt++] = temp;
        cin >> temp;
    }


    unordered_map<int, string> unbox;
    // 处理数据
    for(int i = 0; i < cnt; ) {
        if(t[i][0] == '#') {
            string father(t[i].begin() + 1, t[i].end());
            int fa = 0;
            if(box[father] == 0) {
                box[father] = kind++;
                unbox[box[father]] = father;
            }
            // 记录该轮父亲的编号
            fa = box[father];
            //vector<int> child;
            i++;        // 准备处理孩子
            while(i < cnt && t[i][0] == '+') {
                string child(t[i].begin() + 1, t[i].end());
                int ch = 0;
                if(box[child] == 0) {
                    box[child] = kind++;
                    unbox[box[child]] = child;
                }
                ch = box[child];
                // ch与fa的顺序不能反
                merge(ch, fa);
                i++;
            }

        } 
        else if(t[i][0] == '?') {
            string qe(t[i].begin() + 1, t[i].end());
            int num = box[qe];
            num = find(num);
            string fa = unbox[num];
            cout << qe << " " << fa << endl;
            i++;
        }

    }
    return 0;
}
```

