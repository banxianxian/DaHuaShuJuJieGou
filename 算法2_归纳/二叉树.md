<div align=center><font size=7>二叉树</font></div>

[TOC]

**特别提醒：** 如果题目没有特别说明，那么不一定是二叉树



##### 二叉树的一些性质

1. 对根节点标**1**，则对于第**i**号节点，它的左子树的编号为**2*i**，右子树编号为**2 * i + 1**

2. 层数为**h**的完美二叉树（满二叉树）的节点个数为$2^h - 1$
3. 由前序和中序可以得到唯一后序，由后序和中序可以得到唯一前序，但是由**前序和后序不可得到唯一的中序**



##### 二叉树的表示

**数组表示：** 利用性质1实现。

​					适合层数较少的情况，**越靠近完美二叉树越好**。

**结构体数组表示：** 

```c++
struct node {
	int left;
    int right;
} t[maxN]
```





##### 题解

###### Luogu4913

用结构体表示二叉树

```c++
// 使用结构体表示二叉树
#include <iostream>
using namespace std;
int n;
struct node {
    int left;
    int right;
};
node t[1000090]; 
int dfs(int i) {
    if(t[i].left == 0 && t[i].right == 0) {
        return 1;
    }

    int left = dfs(t[i].left);
    int right = dfs(t[i].right);
    return max(left, right) + 1;

}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> t[i].left >> t[i].right;
    }

    cout << dfs(1) << endl;

    return 0;
}
```

###### Luogu1305

本题可以不用建树。

**注意：** 字母应该只能为小写的26个英文字母，和*号

要记录根节点（开始时的下标）。将字母转为数字，并用结构体表示。

```c++
#include <iostream>
using namespace std;
struct node
{
    int left;
    int right;
};

int n;
node t[30];
void pre_dfs(int k) {
    if(k == 0) return;
    cout << char(k + 'a' - 1);
    pre_dfs(t[k].left);
    pre_dfs(t[k].right);
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    int start = 0;          // 标记根节点
    for(int i = 0; i < n; i++) {
        char a1 = 0, a2 = 0, a3 = 0;
        cin >> a1 >> a2 >> a3;
        if(i == 0) start = a1 - 'a' + 1;

        if(a2 != '*') t[a1 - 'a' + 1].left = a2 - 'a' + 1;       
        else t[a1 - 'a' + 1].left = 0;
        if(a3 != '*') t[a1 - 'a' + 1].right = a3 - 'a' + 1;
        else t[a1 - 'a' + 1].right = 0;
    }

    pre_dfs(start);
    return 0;
}
```

###### Luogu1030

**要注意边界条件：**

1. 传入的树按照左闭右开区间
2. 递归结束条件是树至少有一个元素

```c++
#include <iostream>
#include <cstring>
using namespace std;
string s1;
string s2;
void dfs(int l1, int r1, int l2, int r2) {
    // 左闭右开
    if(l1 >= r1 || l2 >= r2) {
        return;
    }
    cout << s2[r2 - 1];

    int x = s1.find(s2[r2 - 1]);
    int leftL = x - l1;
    int leftR = r1 - x - 1;
    // 遍历左树
    dfs(l1, x, l2, l2 + leftL);
    // 遍历右树
    dfs(x + 1, r1, r2 - leftR - 1, r2 - 1);
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> s1 >> s2;        
    dfs(0, s1.size(), 0, s2.size());
    return 0;
}
```

###### Luogu1087

该树一定为完美二叉树，所以使用**第一种方式**表示二叉树。

本题其实也可以不用建树。

**注意：** 当[start, end)，中间mid = (end + start) / 2，而不是mid = end / 2	(当start=0时，才成立)

```c++
#include <bits/stdc++.h>
using namespace std;
int N;
int height;
string str;
struct node {
    char ch;
    int depth;
};
node tree[3000];
void build(int start, int end, int depth, int num) {
    if(start >= end) {
        return;
    }
    // 判断str[start:end]类型
    string temp = str.substr(start, end - start);
    int isZero = 0;
    int isOne = 0;
    isZero = temp.find('0');
    isOne = temp.find('1');
    if(isZero != string::npos && isOne != string::npos) {
        tree[num].ch = 'F';
        build(start, (end + start )/ 2, depth + 1, 2 * num);
        build((end + start) / 2, end, depth + 1, 2 * num + 1);
    }
    else if(isZero != string::npos) {
        tree[num].ch = 'B';
    }
    else {
        tree[num].ch = 'I';
    }

    tree[num].depth = depth;
    return;
}
void dfs(int index) {
    if(tree[index].ch == 'B') {
        int t = height - tree[index].depth + 1;
        for(int i = 0; i < (1 << t) - 1; i++) {
            cout << "B";
        }
        return;
    }
    else if(tree[index].ch == 'I') {
        int t = height - tree[index].depth + 1;
        for(int i = 0; i < (1 << t) - 1; i++) {
            cout << "I";
        }
        return;
    }
    dfs(2 * index);
    dfs(2 * index + 1);
    cout << tree[index].ch;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> N >> str;
    height = N + 1;
    build(0, 1 << N, 1, 1);    // 左闭右开
    dfs(1);
    return 0;
}
```

###### Luogu1364

采用结构体表示二叉树。

该代码的时间复杂度为O($n^2$)，深搜部分为O(n)

```c++
#include <iostream>
#include <climits>
#include <cstring>
using namespace std;
struct node {
    int left;
    int right;
    int father;
    int weight;
} tree[105];
int n;
int isvisted[105];
int dfs(int index, int dis) {
    if(index == 0 || isvisted[index]) {
        return 0;
    }
    isvisted[index] = true;
    return dfs(tree[index].left, dis + 1) + dfs(tree[index].right, dis + 1) 
    + dfs(tree[index].father, dis + 1) + dis * tree[index].weight;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> tree[i].weight >> tree[i].left >> tree[i].right;
    }

    // 初始化父节点
    for(int i = 1; i <= n; i++) {
        tree[tree[i].left].father = i;
        tree[tree[i].right].father = i;
    }

    // 遍历每一个点，求解最小情况
    int ans = INT_MAX;
    for(int i = 1; i <= n; i++) {
        memset(isvisted, 0, sizeof(isvisted));
        ans = min(ans, dfs(i, 0));
    }
    cout << ans << endl;

    return 0;
}
```

