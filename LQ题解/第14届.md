[TOC]







###### LQ有奖问答

**暴力搜索：**

**复杂度:** O($2^n$)

```c++
#include <iostream>
using namespace std;
int ans;
void dfs(int score, int num) {
	if(score >= 100) return;
	else if(score == 70) {
		ans++;
	}
    
	if(num == 30) return;
	
	// 继续回答的情况
	// 回答正确 
	dfs(score + 10, num + 1);
	// 回答错误 
	dfs(0, num + 1);
}
int main() {
	
	dfs(0, 0);
	cout << ans << endl;
	return 0;
}
```

**动态规划：**

**复杂度: **O($n^2$)

5步:

1. 使用动态规划方式求解，如果得90，则记为9 
2. 状态定义：dp[i] [j]代表回答i道题，得分为j的方案数 
3. 转移方程：	if j == 0: dp[i][j] = dp[i - 1] [9] + ... + dp[i - 1] [0] 
   						if j != 0: dp[i] [j] = dp[i - 1] [j - 1]
4. 状态初始化：dp[0] [0] = 1



```c++
#include <iostream>
using namespace std;
 
int dp[40][100];
int ans;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	// 状态初始化 
	dp[0][0] = 1;
	
	for(int j = 1; j <= 10; j++) {
		dp[0][j] = 0;
	}
	
	for(int i = 1; i <= 30; i++) {
		for(int j = 0; j <= 10; j++) {
			if(j == 0) {
				for(int k = 0; k <= 9; k++) dp[i][0] += dp[i - 1][k];
			}
			else {
				dp[i][j] = dp[i - 1][j - 1];
			}
		}
	}
	
	
	for(int i = 0; i <= 30; i++) ans += dp[i][7];
	cout << ans << endl;
	return 0;
}
```





###### LQ平方差

```c++
#include <iostream>
using namespace std;
const int maxn = 1000;
string a;
string b;
int A[maxn];
int B[maxn];
int AA[maxn];
int BB[maxn];
int chengfa(int t1[], int t2[], int ans[], int len1, int len2) {
	int len = len1 + len2;
	for(int i = 1; i <= len1; i++) {
		for(int j = 1; j <= len2; j++) {
			ans[i + j - 1] += t1[i] * t2[j];
		}
	}	
	
	for(int i = 1; i <= len; i++) {
		ans[i + 1] += ans[i] / 10;
		ans[i] %= 10;
	}
	
	while(ans[len] == 0) len--;
	
	return len;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> a >> b;
	
	
	// 将a与b转为A与B
	int lenA = a.size();
	int lenB = b.size() ;
	if(a[0] == '-') a.erase(0, 1), lenA--;
	if(b[0] == '-') b.erase(0, 1), lenB--;
	
	for(int i = 1; i <= lenA; i++) {
		A[i] = a[lenA - i] - '0';
	}
	
	for(int i = 1; i <= lenB; i++) {
		B[i] = b[lenB - i] - '0';
	}
	
	// 为了减少减法，不进行展开计算
	int lenAA = chengfa(A, A, AA, lenA, lenA);
	int lenBB = chengfa(B, B, BB, lenB, lenB);
	
	
	// 对AA与BB进行减法
	// 判断AA与BB谁更大
	int status = 0;			// status = 1, AA大，反之status = -1, 则BB大，status == 0则一样大 
	if(lenAA != lenBB) {
		status = lenAA > lenBB? 1 : -1;
	} 
	else {
		int t = lenAA;
		for(int i = t; i >= 1; i--) {
			if(AA[i] != BB[i]) {
				status = AA[i] > BB[i]? 1 : -1;
				break;
			}
		}
	}
	
	int *greater;
	int *smaller;
	int sym = 0;	// 代表符号 
	int lenG = 0, lenS = 0;
	if(status == 0) {
		cout << "0" << endl;
		return 0;
	}
	else if(status == 1) {
		greater = AA;
		smaller = BB;
		sym = 1;
		lenG= lenAA;
		lenS = lenBB;
	}
	else {
		greater = BB;
		smaller = AA;
		sym = -1;
		lenG = lenBB;
		lenS = lenAA;
	}
	
	// 开始减法
	int outcome[maxn] = {0};
	for(int i = 1; i <= lenG; i++) {
		if(greater[i] < smaller[i]) {
			greater[i + 1]--;
			greater[i] += 10;	
		}
		outcome[i] = greater[i] - smaller[i];
	}
	
	// 去除前导0
	int lenO = lenG;
	while(outcome[lenO] == 0) lenO--;
	
	if(sym == -1) cout << "-";
	for(int i = lenO; i >= 1; i--) cout << outcome[i]; 
	
	return 0;
}
```



###### LQ更小的数

**暴力求解：**

```c++
#include <iostream>
#include <iostream>
using namespace std;
string t;
long long ans;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> t;
	for(int i = 0; i < t.size(); i++) {
		for(int j = i + 1; j < t.size(); j++) {
			int pre = i;
			int lat = j;
			int status = 0;
			while(t[lat] == t[pre]) {
				if(lat - pre == 2) {
					status = 1;
					break;
				}
				else if(lat - pre == 1) {
					status = 1;
					break;
				}
				pre++;
				lat--;
			}
			if(status == 0) {
				ans = t[lat] < t[pre]? ans + 1 : ans;
			}
			
		}
	}
	cout << ans << endl;
	
	return 0;
}
```



**动态规划：**

需要注意遍历的顺序.

```c++
#include <iostream>
#include <vector>
using namespace std;
string t;
int ans;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> t;
	
	int len = t.size();
	vector<vector<bool>> dp(len, vector<bool>(len, 0));
	// 初始化，对角线均为0
	// 遍历方向为从左向右，从上到下
	
	for(int j = 0; j < len; j++) {
		for(int i = 0; i < j; i++) {
			if(t[i] > t[j]) {
				dp[i][j] = true;
			}
			else if(t[i] < t[j]) {
				dp[i][j] = false;
			}
			else {
				// 此时递推不成立仅当i + 1 = j，而如果s[i] == s[j] ，表明交换无效
				dp[i][j] = dp[i + 1][j - 1]; 
			}
			
			ans += dp[i][j];
		}
	}
	cout << ans << endl; 
	
	
	
	return 0;
}
```



###### LQ买瓜

**暴力解法：**

只能通过部分样例(9个，一共20个)

**时间复杂度： ** O($3^n$)

```c++
#include <iostream>
#include <vector>
using namespace std;
double nums[1000];
int n, m;
int ans = 1e9;
void dfs(double n_m, int number, int index) {
	if(number > ans) return;
	if(n_m == m) {
		ans = min(ans, number);
		return;
	}
	else if(index >= n) {
		return;
	}
	
	// 有三种情况，选，不选，选一半
	// 选 
	dfs(n_m + nums[index], number, index + 1); 
	// 不选
	dfs(n_m, number, index + 1);
	// 选一半 
	dfs(n_m + nums[index] / 2, number + 1, index + 1);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	for(int i = 0; i < n; i++) {
		double temp = 0;
		cin >> temp;
		nums[i] = temp;
	}
	
	
	dfs(0, 0, 0);
	if(ans != 1e9) cout << ans << endl;
	else cout << "-1" << endl;
	return 0;
}
```



**折半搜索：**

可以通过17个样例

第65行的排序，可以有效提高速度，但是还不知道原因

**时间复杂度：** O($3^{n/2}$)

```c++
#include <iostream>
#include <unordered_map>
#include <algorithm>
using namespace std;
int n, m;
long long nums[50];
long long ans = 1e9;
unordered_map<long long, long long> h;
void dfs1(int index, long long total, long long number) {
	// 前面两个if可以return，不会影响后面结果，因为如果后面还要再分 ，一定超越了现在的结果 
	if(number > ans || total > m) {
		return;
	}
	if(total == m) {
		ans = min(ans, number);
		return;
	}
	else if(index >= n / 2) {
		if(h.count(total)) {
			h[total] = min(h[total], number);
		}
		else {
			h[total] = number;
		}
		return;
	}
	
	// 不选该瓜 
	dfs1(index + 1, total, number);
	// 选择该瓜
	dfs1(index + 1, total + nums[index], number);
	// 砍瓜
	dfs1(index + 1, total + nums[index] / 2, number + 1); 
	
}

void dfs2(int index, long long total, long long number) {
	if(number > ans || total > m) return;
	if(total == m) {
		ans = min(ans, number);
		return;
	}
	if(h.count(m - total)) {
		ans = min(ans, h[m - total] + number);
        return;
	}
	if(index >= n) return;
	
	dfs2(index + 1, total, number);
	dfs2(index + 1, total + nums[index], number);
	dfs2(index + 1, total + nums[index] / 2, number + 1);
	
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	// 对数据乘2之后，再除的时候可以避免出现分数 
	cin >> n >> m;
	m <<= 1;
	for(int i = 0; i < n; i++) {
		cin >> nums[i];
		nums[i] <<= 1;
	}
    sort(nums, nums + n);
	dfs1(0, 0, 0);
	dfs2(n / 2 , 0, 0);
	if(ans == 1e9) cout << "-1" << endl;
	else cout << ans << endl;
	return 0;
}
```

