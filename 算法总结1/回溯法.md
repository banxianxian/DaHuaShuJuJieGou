# 回溯法

### 回溯法用于解决的问题

回溯法本质上是一种暴力枚举法，可以通过递归表示循环层数不确定的问题，常见有以下几类问题

- 组合问题
- 切割问题
- 子集问题
- 排列问题
- 棋盘问题

#### 组合问题

N个数中按照一定的规则找出全部k个数的集合。

可以形象的将其看作一个树的结构，解决问题所需的循环层数为递归的深度（树的深度），递归中的for循环代表宽度。

可以通过剪枝进行优化，再下面两个方面：

- 递归终点
- for循环的范围

代码模板：

```c++
vector<vector<int>> box;		//用于存储全部满足条件的组合
vector<int> target;				//用于存储一个满足条件的组合
void backtracking(int startIndex, ...) {
    if(循环结束条件) {
        box.push_back(target);	//将满足条件的结果放入box中
        return;
    }
    
    for(int i = start; i <= end; i++) {
        target.push_back(合适的数据);
        backtracking(...);		//进行递归
        target.pop_back();		//进行回溯过程
    }
    
}
```

#### 切割问题

将一个字符串切割成若干个子串

与组合问题类似，难点在于怎么模拟切割的过程。

代码模板：

```c++
	vector<string> target;
    vector<vector<string>> box;
    void backtracking(string s, int startIndex...) {
        if(循环结束条件) {
            box.push_back(target);
            return;
        }
        for(int i = startIndex; i < endIndex; i++) {
            //模拟切割子串,截取下标从startIndex开始长度为i - startIndex + 1
            string temp = s.substr(startIndex, i - startIndex + 1);
            if(子串符合条件) {
                target.push_back(temp);
            }
            else {
                continue;
            }
            backtracking(s, i + 1,...);
            target.pop_back();
        }
    }
```

#### 子集问题

子集问题与组合的一个区别在于组合问题只需要收集合适的叶子节点，但子集问题需要收集全部节点。

一般不剪枝

代码模板:

```c++
	vector<int> target;
    vector<vector<int>> box;
    void backtracking(vector<int>& nums, int startIndex...) {
        box.push_back(target);			//没有判断条件
        for(int i = startIndex; i < nums.size(); i++) {
            target.push_back(nums[i]);
            backtracking(nums, i + 1...);
            target.pop_back();
        }
    }
    
```

#### 排列问题

排列问题相对与组合for从0开始，同时避免在树的下一层选到自己

一般不剪枝

代码模板：

```c++
	vector<int> target;
    vector<vector<int>> box;
	vector<bool> isUsed(nums.size())
	//isUsed数组用来判断该元素是否使用过
    void backtracking(vector<int>& nums, vector<bool>& isUsed...) {
        if(target.size() == nums.size()) {
            box.push_back(target);
            return;
        }
        //从0开始，通过isUsed数组避免重复使用一个元素
        for(int i = 0; i < nums.size(); i++) {
            if(isUsed[i]) continue;
            target.push_back(nums[i]);
            isUsed[i] = true;
            backtracking(nums, isUsed,...);
            isUsed[i] = false;
            target.pop_back();
        }
    }
  
```



