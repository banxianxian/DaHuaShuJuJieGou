<div align=center><font size=6>动态规划——背包问题</font></div>

#### 背包问题分类

- 01背包        ：每种物品**只有一个**选或者不选
- 完全背包     ：每种物品**有无数个**选或者选几个
- 多重背包     ：不同物品**个数不同**选或者选几个
- 分组背包     ： 

下面主要解释<u>01背包</u>和<u>完全背包</u>

#### 01背包

原理：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

![](https://github.com/banxianxian/image/blob/main/DaHuaShuJuJieGou/01%E8%83%8C%E5%8C%85.png?raw=true)

观察改该图：使用回溯的复杂度为**O(2^n)**，存在大量子问题，满足决策树模型，并且有最优之类的描述。

大概率可以使用动态规划。

1-	确定dp数组

考虑对于每个物品，放入背包，背包容量减少，不放入背包，背包容量不变。应该由物品和容量来决定。

dp[i] [j] = k， **表示**前i个物品，在背包容量为j时，的最大价值为k。

2-	确定递推公式

考虑决策：**放**或者**不放**

不放的话：dp[i] [j] = dp[i - 1] [j] 

放的话：dp[i] [j] = dp[i - 1] [j - weight[i]] + value[i]

从而递推公式为：dp[i] [j] = max(dp[i - 1] [j],	dp[i - 1] [j - weight[i]] + value[i])

3- dp数组初始化

当背包容量为0时，dp[i] [0] = 0 表示无法存放任何东西，价值为0

当只有第0件物品时，dp[0] [j] = 0 || value[0] ,如果背包容量大于weight[0]，则为value[0]，否则为0。

4- 遍历的顺序

略

5- 举例尝试

略

#### 实现代码

hello算法上面的实现：初始化不同，它的i = 0 不是代表第0件物品，而是没有物品的情况。

而wgt并未存储i = 0 的情况，使用第i件物品的大小为weight[i - 1]，价值为val[i - 1]

```c++
/* 0-1 背包：动态规划 */
int knapsackDP(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n + 1, vector<int>(cap + 1, 0));
    // 状态转移
    for (int i = 1; i <= n; i++) {
        for (int c = 1; c <= cap; c++) {
            if (wgt[i - 1] > c) {
                // 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c];
            } else {
                // 不选和选物品 i 这两种方案的较大值
                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);
            }
        }
    }
    return dp[n][cap];
}


```

将第0件看作第0件物品：

```c++
/* 0-1 背包：动态规划 */
int knapsackDP(vector<int> &wgt, vector<int> &val, int cap) {
    int n = wgt.size();
    // 初始化 dp 表
    vector<vector<int>> dp(n, vector<int>(cap + 1, 0));
    for(int j = weight[0]; j <= cap; j++) {
        dp[0][j] = value[0];
    }
    // 状态转移
    for (int i = 0; i < n; i++) {
        for (int c = 1; c <= cap; c++) {
            if (wgt[i] > c) {
                // 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c];
            } else {
                // 不选和选物品 i 这两种方案的较大值
               dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i]] + val[i]);
            }
        }
    }
    return dp[n - 1][cap];
}
```

记忆化搜索：mem为记忆化数组

```c++
/* 0-1 背包：记忆化搜索 */
int knapsackDFSMem(vector<int> &wgt, vector<int> &val, vector<vector<int>> &mem, int i, int c) {
    // 若已选完所有物品或背包无容量，则返回价值 0
    if (i == 0 || c == 0) {
        return 0;
    }
    // 若已有记录，则直接返回
    if (mem[i][c] != -1) {
        return mem[i][c];
    }
    // 若超过背包容量，则只能不放入背包
    if (wgt[i - 1] > c) {
        return knapsackDFSMem(wgt, val, mem, i - 1, c);
    }
    // 计算不放入和放入物品 i 的最大价值
    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);
    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];
    // 记录并返回两种方案中价值更大的那一个
    mem[i][c] = max(no, yes);
    return mem[i][c];
}

```

#### 如何将问题转换为01背包，几道例题

[leecode416](https://leetcode.cn/problems/partition-equal-subset-sum/)

题目描述：给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等.

问题转化：在数组中挑选一些数，使得其**目标和**为sum / 2

与背包问题的相似点：

- 将<u>数字</u>对应于<u>物品</u>，<u>数字大小</u>对应于<u>物品重量</u>，<u>目标和</u>对应于<u>背包容量</u>
- 优化目标：背包问题求最大价值，该问题求最大和

不同点：

- 背包问题求不超过背包容量下的最优解，该问题为恰好达到目标和的解

```c++
// dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);	滚动数组
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i])            
if(dp[j] == sum) return true;
```

[leecode1049](https://leetcode.cn/problems/last-stone-weight-ii/)

题目描述：有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

问题转化：与上面一题几乎相同。

不同点：

- 背包问题求不超过背包容量下的最优解，该问题求不超过目标和下的最大值

#### 01背包解决组合问题

01背包可以用来求解满足条件的组合个数，但是不能求解满足条件的每个组合是什么。

[leecode494](https://leetcode.cn/problems/target-sum/)

题目描述：

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。



问题转化：可分为两堆，一堆为-，一堆为+，-的和为right，+的和为left，则:

right + left = sum	left - right = target

所有left = (sum + target) / 2

即求在数组nums中**组合**的和为left的**解的个数**。

确定关键的状态转移方程：dp[i] [j] = dp[i - 1] [j] + dp[i - 1] [j - nums[i]]

```c++
int findTargetSumWays(vector<int>& nums, int target) {
        int left = 0;
        int sum = accumulate(nums.begin(), nums.end(), 0);
        left = (sum + target) / 2;
        if((sum + target) % 2 != 0) return 0;
        if(left + 1 < 0) return 0;
        vector<vector<int>> dp(nums.size(), vector<int>(left + 1, 0));
        // 初始化
        for(int j = 0; j <= left; j++) {
            if(j == 0 || j == nums[0]) {
                dp[0][j] = 1;
            }
        }

        if(nums[0] == 0) dp[0][0] = 2;
        else dp[0][0] = 1;

        for(int i = 1; i < nums.size(); i++) {
            for(int j = 0; j <= left; j++) {
                if(j >= nums[i]) dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
                else dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[nums.size() - 1][left];

    }
```

 